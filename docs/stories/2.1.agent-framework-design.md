# Story 2.1: Agent基础框架设计

## Status
Draft

## Story

**As a** AI工程师,
**I want** 设计Agent的基础架构和接口规范,
**so that** 实现标准化的智能体开发模式。

## Acceptance Criteria

1. 设计Agent基类，定义标准接口(分析、决策、通信等)
2. 实现Agent注册和发现机制
3. 设计Agent间通信协议和数据格式
4. 创建Agent状态管理和上下文传递机制
5. 实现Agent配置管理和参数调优接口

## Tasks / Subtasks

- [ ] 设计Agent基础架构 (AC: #1)
  - [ ] 创建Agent基类
    - [ ] 定义Agent核心接口(analyze, communicate, update_state等)
    - [ ] 实现Agent生命周期管理(init, start, stop, cleanup)
    - [ ] 设计Agent抽象方法供子类实现
    - [ ] 添加Agent元数据和配置属性
  - [ ] 定义Agent接口规范
    - [ ] IAgent接口定义所有必需方法
    - [ ] ICommunicator接口定义通信方法
    - [ ] IAnalyzer接口定义分析方法
    - [ ] IConfigurable接口定义配置方法
  - [ ] 设计Agent类型系统
    - [ ] 定义AgentType枚举(S_AGENT, A_AGENT, F_AGENT, E_AGENT, R_AGENT)
    - [ ] 实现Agent类型验证和转换
    - [ ] 创建Agent类型注册机制
    - [ ] 支持自定义Agent类型扩展
  - [ ] 实现Agent工厂模式
    - [ ] 创建AgentFactory工厂类
    - [ ] 实现基于配置的Agent创建
    - [ ] 支持Agent实例池管理
    - [ ] 实现Agent依赖注入机制
  - [ ] 创建Agent工具类
    - [ ] AgentRegistry - Agent注册表
    - [ ] AgentValidator - Agent验证器
    - [ ] AgentUtils - Agent工具方法
    - [ ] AgentMetrics - Agent性能指标

- [ ] 实现Agent注册和发现机制 (AC: #2)
  - [ ] 设计Agent注册系统
    - [ ] 创建AgentRegistry注册表
    - [ ] 实现Agent唯一标识管理
    - [ ] 支持Agent类型和标签分类
    - [ ] 实现Agent状态跟踪
  - [ ] 实现Agent发现机制
    - [ ] 基于类型的Agent查找
    - [ ] 基于状态的Agent过滤
    - [ ] 支持Agent能力查询
    - [ ] 实现Agent依赖关系发现
  - [ ] 创建Agent管理器
    - [ ] AgentManager统一管理所有Agent
    - [ ] 实现Agent生命周期管理
    - [ ] 支持Agent动态添加和移除
    - [ ] 提供Agent健康检查功能
  - [ ] 实现Agent服务发现
    - [ ] 支持Agent服务注册
    - [ ] 实现服务发现协议
    - [ ] 支持服务负载均衡
    - [ ] 提供服务健康监控
  - [ ] 创建Agent配置管理
    - [ ] 支持Agent配置文件管理
    - [ ] 实现动态配置更新
    - [ ] 提供配置验证机制
    - [ ] 支持配置版本管理

- [ ] 设计Agent间通信协议 (AC: #3)
  - [ ] 定义消息格式标准
    - [ ] AgentMessage消息基类
    - [ ] 消息类型枚举(REQUEST, RESPONSE, NOTIFICATION, ERROR)
    - [ ] 消息优先级机制
    - [ ] 消息序列化和反序列化
  - [ ] 实现通信接口
    - [ ] ICommunicator通信接口
    - [ ] MessageBus消息总线
    - [ ] MessageQueue消息队列
    - [ ] MessageRouter消息路由
  - [ ] 创建通信传输层
    - [ ] MemoryTransport内存传输
    -   RedisTransport Redis传输
    - [ ] HTTPTransport HTTP传输
    - [ ] WebSocketTransport WebSocket传输
  - [ ] 实现消息路由机制
    - [ ] 基于AgentID的直接路由
    - [ ] 基于Agent类型的广播路由
    - [ ] 基于标签的条件路由
    - [ ] 支持消息转发和代理
  - [ ] 设计通信安全机制
    - [ ] 消息加密和签名验证
    - [ ] Agent身份认证
    - [ ] 通信权限控制
    - [ ] 消息审计日志

- [ ] 创建Agent状态管理 (AC: #4)
  - [ ] 设计Agent状态模型
    - [ ] AgentState状态枚举(INITIALIZING, IDLE, BUSY, ERROR, STOPPED)
    - [ ] 状态转换规则和验证
    - [ ] 状态变更历史记录
    - [ ] 状态持久化机制
  - [ ] 实现状态管理器
    - [ ] StateManager状态管理器
    - [ ] 状态变更通知机制
    - [ ] 状态监控和告警
    - [ ] 状态恢复和回滚
  - [ ] 创建上下文传递机制
    - [ ] Context上下文对象
    - [ ] 上下文数据结构设计
    - [ ] 上下文传递和共享
    - [ ] 上下文生命周期管理
  - [ ] 实现会话管理
    - [ ] Session会话管理器
    - [ ] 会话数据持久化
    - [ ] 会话超时和清理
    - [ ] 多会话并发管理
  - [ ] 设计内存管理
    - [ ] Agent实例内存管理
    - [ ] 消息内存管理
    - [ ] 上下文内存管理
    - [ ] 垃圾回收和优化

- [ ] 实现Agent配置管理 (AC: #5)
  - [ ] 设计配置数据模型
    - [ ] AgentConfig配置基类
    - [ ] 配置文件格式(JSON/YAML/TOML)
    - [ ] 配置验证Schema
    - [ ] 配置默认值管理
  - [ ] 创建配置管理器
    - [ ] ConfigManager配置管理器
    - [ ] 配置加载和保存
    - [ ] 配置热更新机制
    - [ ] 配置变更通知
  - [ ] 实现参数调优接口
    - [ ] TuningParameters调优参数类
    - [ ] 参数优化算法接口
    - [ ] A/B测试支持
    - [ ] 性能监控和分析
  - [ ] 创建配置模板系统
    - [ ] AgentType配置模板
    - [ ] 场景配置模板
    - [ ] 环境配置模板
    - [ ] 自定义配置模板
  - [ ] 实现配置验证机制
    - [ ] 配置完整性验证
    - [ ] 配置一致性检查
    - [ ] 配置依赖关系验证
    - [ ] 配置错误报告

## Dev Notes

### 技术架构信息
Agent框架采用模块化和可扩展设计：
- 基础框架: Python 3.9+ + 抽象基类
- 通信框架: 基于消息传递的异步通信
- 状态管理: 状态机模式 + 上下文传递
- 配置管理: 配置文件 + 动态更新机制
- 注册发现: 注册表模式 + 服务发现

### Agent基础类设计
```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Union
from enum import Enum
from dataclasses import dataclass
import asyncio
import uuid
import time
import json

class AgentType(Enum):
    """Agent类型枚举"""
    S_AGENT = "s-agent"      # 战略家
    A_AGENT = "a-agent"      # 感知者
    F_AGENT = "f-agent"      # 专家
    E_AGENT = "e-agent"      # 执行者
    R_AGENT = "r-agent"      # 复盘评估者

class AgentState(Enum):
    """Agent状态枚举"""
    INITIALIZING = "initializing"
    IDLE = "idle"
    BUSY = "busy"
    ERROR = "error"
    STOPPED = "stopped"

@dataclass
class AgentMessage:
    """Agent消息"""
    id: str
    sender_id: str
    receiver_id: Optional[str]
    message_type: str
    content: Dict[str, Any]
    timestamp: float
    priority: int = 1
    correlation_id: Optional[str] = None

class BaseAgent(ABC):
    """Agent基础类"""

    def __init__(self, agent_id: str, agent_type: AgentType, config: Dict[str, Any]):
        self.agent_id = agent_id
        self.agent_type = agent_type
        self.config = config
        self.state = AgentState.INITIALIZING
        self.context = {}
        self.communication_handlers = {}
        self.metrics = {
            'messages_sent': 0,
            'messages_received': 0,
            'analysis_count': 0,
            'error_count': 0,
            'uptime': 0
        }

    @abstractmethod
    async def analyze(self, scenario_data: Dict[str, Any]) -> Dict[str, Any]:
        """分析数据方法"""
        pass

    @abstractmethod
    async def communicate(self, message: AgentMessage) -> Optional[AgentMessage]:
        """通信方法"""
        pass

    @abstractmethod
    async def update_state(self, new_state: AgentState) -> bool:
        """状态更新方法"""
        pass

    async def initialize(self) -> bool:
        """初始化Agent"""
        try:
            await self._setup_communication()
            await self._load_configuration()
            await self._register_agent()
            self.state = AgentState.IDLE
            return True
        except Exception as e:
            self.state = AgentState.ERROR
            logger.error(f"Agent {self.agent_id} initialization failed: {e}")
            return False

    async def start(self) -> bool:
        """启动Agent"""
        if self.state == AgentState.IDLE:
            self.state = AgentState.BUSY
            return True
        return False

    async def stop(self) -> bool:
        """停止Agent"""
        if self.state in [AgentState.BUSY, AgentState.IDLE]:
            self.state = AgentState.STOPPED
            return True
        return False

    async def cleanup(self):
        """清理资源"""
        await self._unregister_agent()
        await self._cleanup_communication()
        self.state = AgentState.STOPPED
```

### 通信协议设计
```python
from typing import Protocol, Callable
from dataclasses import dataclass

class MessageProtocol(Protocol):
    """消息协议接口"""
    def serialize(self, message: AgentMessage) -> bytes:
        """序列化消息"""
        pass

    def deserialize(self, data: bytes) -> AgentMessage:
        """反序列化消息"""
        pass

@dataclass
class MessageMetadata:
    """消息元数据"""
    message_id: str
    sender_id: str
    receiver_id: Optional[str]
    timestamp: float
    priority: int
    correlation_id: Optional[str] = None
    reply_to: Optional[str] = None
    expires_at: Optional[float] = None

class MessageBus:
    """消息总线"""

    def __init__(self):
        self.subscribers = {}
        self.message_handlers = {}
        self.message_queue = asyncio.Queue()

    def subscribe(self, agent_id: str, handler: Callable) -> None:
        """订阅消息"""
        if agent_id not in self.subscribers:
            self.subscribers[agent_id] = []
        self.subscribers[agent_id].append(handler)

    def unsubscribe(self, agent_id: str, handler: Callable) -> None:
        """取消订阅"""
        if agent_id in self.subscribers:
            if handler in self.subscribers[agent_id]:
                self.subscribers[agent_id].remove(handler)

    async def publish(self, message: AgentMessage) -> bool:
        """发布消息"""
        try:
            if message.receiver_id:
                # 直接发送
                await self._send_direct_message(message)
            else:
                # 广播消息
                await self._broadcast_message(message)
            return True
        except Exception as e:
            logger.error(f"Failed to publish message {message.id}: {e}")
            return False

    async def _send_direct_message(self, message: AgentMessage):
        """发送直接消息"""
        if message.receiver_id in self.subscribers:
            for handler in self.subscribers[message.receiver_id]:
                await handler(message)

    async def _broadcast_message(self, message: AgentMessage):
        """广播消息"""
        for agent_id, handlers in self.subscribers.items():
            if agent_id != message.sender_id:
                for handler in handlers:
                    await handler(message)
```

### 状态管理实现
```python
from typing import Dict, Any, Optional
from datetime import datetime
import asyncio

class StateManager:
    """状态管理器"""

    def __init__(self):
        self.agent_states = {}
        self.state_history = {}
        self.state_listeners = {}

    async def update_state(self, agent_id: str, new_state: AgentState,
                          context: Optional[Dict[str, Any]] = None) -> bool:
        """更新Agent状态"""
        try:
            old_state = self.agent_states.get(agent_id)

            # 验证状态转换
            if not self._is_valid_transition(old_state, new_state):
                logger.warning(f"Invalid state transition for {agent_id}: {old_state} -> {new_state}")
                return False

            # 更新状态
            self.agent_states[agent_id] = new_state

            # 记录状态历史
            if agent_id not in self.state_history:
                self.state_history[agent_id] = []

            self.state_history[agent_id].append({
                'old_state': old_state.value if old_state else None,
                'new_state': new_state.value,
                'timestamp': datetime.now().isoformat(),
                'context': context
            })

            # 通知监听器
            await self._notify_listeners(agent_id, old_state, new_state, context)

            return True

        except Exception as e:
            logger.error(f"Failed to update state for {agent_id}: {e}")
            return False

    def get_state(self, agent_id: str) -> Optional[AgentState]:
        """获取Agent状态"""
        return self.agent_states.get(agent_id)

    def get_state_history(self, agent_id: str, limit: int = 10) -> List[Dict]:
        """获取状态历史"""
        if agent_id not in self.state_history:
            return []
        return self.state_history[agent_id][-limit:]

    def add_state_listener(self, agent_id: str, listener: Callable) -> None:
        """添加状态监听器"""
        if agent_id not in self.state_listeners:
            self.state_listeners[agent_id] = []
        self.state_listeners[agent_id].append(listener)

    def remove_state_listener(self, agent_id: str, listener: Callable) -> None:
        """移除状态监听器"""
        if agent_id in self.state_listeners:
            if listener in self.state_listeners[agent_id]:
                self.state_listeners[agent_id].remove(listener)

    async def _notify_listeners(self, agent_id: str, old_state: AgentState,
                              new_state: AgentState, context: Dict[str, Any]):
        """通知状态监听器"""
        if agent_id in self.state_listeners:
            for listener in self.state_listeners[agent_id]:
                try:
                    await listener(old_state, new_state, context)
                except Exception as e:
                    logger.error(f"State listener error for {agent_id}: {e}")

    def _is_valid_transition(self, old_state: Optional[AgentState],
                           new_state: AgentState) -> bool:
        """验证状态转换是否有效"""
        # 定义有效的状态转换规则
        valid_transitions = {
            None: [AgentState.INITIALIZING],
            AgentState.INITIALIZING: [AgentState.IDLE, AgentState.ERROR],
            AgentState.IDLE: [AgentState.BUSY, AgentState.STOPPED, AgentState.ERROR],
            AgentState.BUSY: [AgentState.IDLE, AgentState.ERROR, AgentState.STOPPED],
            AgentState.ERROR: [AgentState.IDLE, AgentState.STOPPED],
            AgentState.STOPPED: [AgentState.INITIALIZING]
        }

        if old_state is None:
            return new_state in valid_transitions[None]

        return new_state in valid_transitions.get(old_state, [])
```

### 配置管理实现
```python
from typing import Dict, Any, Optional, Union
import json
import yaml
from pathlib import Path
import asyncio
from datetime import datetime

class ConfigurationManager:
    """配置管理器"""

    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
        self.config_cache = {}
        self.config_watchers = {}
        self.lock = asyncio.Lock()

    async def load_config(self, agent_id: str, config_file: str) -> Dict[str, Any]:
        """加载配置"""
        try:
            config_path = self.config_dir / config_file
            if not config_path.exists():
                raise FileNotFoundError(f"Config file not found: {config_file}")

            async with self.lock:
                # 检查缓存
                cache_key = f"{agent_id}:{config_file}"
                if cache_key in self.config_cache:
                    cached_time, cached_config = self.config_cache[cache_key]
                    if self._is_cache_valid(config_path, cached_time):
                        return cached_config

                # 加载配置文件
                with open(config_path, 'r', encoding='utf-8') as f:
                    if config_path.suffix.lower() == '.json':
                        config = json.load(f)
                    elif config_path.suffix.lower() in ['.yaml', '.yml']:
                        config = yaml.safe_load(f)
                    else:
                        raise ValueError(f"Unsupported config format: {config_path.suffix}")

                # 缓存配置
                self.config_cache[cache_key] = (datetime.now(), config)

                return config

        except Exception as e:
            logger.error(f"Failed to load config for {agent_id}: {e}")
            raise

    async def save_config(self, agent_id: str, config_file: str,
                          config: Dict[str, Any]) -> bool:
        """保存配置"""
        try:
            config_path = self.config_dir / config_file
            config_path.parent.mkdir(parents=True, exist_ok=True)

            async with self.lock:
                # 保存配置文件
                with open(config_path, 'w', encoding='utf-8') as f:
                    if config_path.suffix.lower() == '.json':
                        json.dump(config, f, indent=2, ensure_ascii=False)
                    elif config_path.suffix.lower() in ['.yaml', '.yml']:
                        yaml.safe_dump(config, f, default_flow_style=False, allow_unicode=True)
                    else:
                        raise ValueError(f"Unsupported config format: {config_path.suffix}")

                # 更新缓存
                cache_key = f"{agent_id}:{config_file}"
                self.config_cache[cache_key] = (datetime.now(), config)

                return True

        except Exception as e:
            logger.error(f"Failed to save config for {agent_id}: {e}")
            return False

    async def update_config(self, agent_id: str, config_file: str,
                           updates: Dict[str, Any]) -> bool:
        """更新配置"""
        try:
            current_config = await self.load_config(agent_id, config_file)
            current_config.update(updates)
            return await self.save_config(agent_id, config_file, current_config)
        except Exception as e:
            logger.error(f"Failed to update config for {agent_id}: {e}")
            return False

    def _is_cache_valid(self, config_path: Path, cached_time: datetime) -> bool:
        """检查缓存是否有效"""
        if not config_path.exists():
            return False

        file_mtime = datetime.fromtimestamp(config_path.stat().st_mtime)
        return file_mtime <= cached_time

@dataclass
class AgentConfig:
    """Agent配置基类"""
    agent_id: str
    agent_type: str
    enabled: bool = True
    max_concurrent_tasks: int = 5
    timeout: float = 30.0
    retry_count: int = 3
    retry_delay: float = 1.0
    memory_limit: int = 1024 * 1024 * 1024  # 1GB
    log_level: str = "INFO"
    custom_settings: Dict[str, Any] = None
```

### Agent注册机制实现
```python
from typing import Dict, List, Optional, Set
from datetime import datetime

class AgentRegistry:
    """Agent注册表"""

    def __init__(self):
        self.agents = {}
        self.agent_types = {}
        self.agent_capabilities = {}
        self.registration_time = {}

    def register_agent(self, agent: BaseAgent) -> bool:
        """注册Agent"""
        try:
            agent_id = agent.agent_id
            agent_type = agent.agent_type

            # 验证Agent
            if not self._validate_agent(agent):
                logger.error(f"Agent validation failed: {agent_id}")
                return False

            # 检查是否已注册
            if agent_id in self.agents:
                logger.warning(f"Agent {agent_id} already registered")
                return False

            # 注册Agent
            self.agents[agent_id] = agent
            self.registration_time[agent_id] = datetime.now()

            # 更新类型统计
            if agent_type not in self.agent_types:
                self.agent_types[agent_type] = []
            self.agent_types[agent_type].append(agent_id)

            logger.info(f"Agent {agent_id} ({agent_type.value}) registered successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to register agent: {e}")
            return False

    def unregister_agent(self, agent_id: str) -> bool:
        """注销Agent"""
        try:
            if agent_id not in self.agents:
                logger.warning(f"Agent {agent_id} not found")
                return False

            agent = self.agents[agent_id]
            agent_type = agent.agent_type

            # 移除Agent
            del self.agents[agent_id]
            del self.registration_time[agent_id]

            # 更新类型统计
            if agent_type in self.agent_types:
                if agent_id in self.agent_types[agent_type]:
                    self.agent_types[agent_type].remove(agent_id)
                if not self.agent_types[agent_type]:
                    del self.agent_types[agent_type]

            logger.info(f"Agent {agent_id} ({agent_type.value}) unregistered successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to unregister agent {agent_id}: {e}")
            return False

    def get_agent(self, agent_id: str) -> Optional[BaseAgent]:
        """获取Agent"""
        return self.agents.get(agent_id)

    def get_agents_by_type(self, agent_type: AgentType) -> List[BaseAgent]:
        """根据类型获取Agent"""
        if agent_type not in self.agent_types:
            return []

        agents = []
        for agent_id in self.agent_types[agent_type]:
            if agent_id in self.agents:
                agents.append(self.agents[agent_id])
        return agents

    def get_all_agents(self) -> Dict[str, BaseAgent]:
        """获取所有Agent"""
        return self.agents.copy()

    def get_agent_count(self) -> int:
        """获取Agent数量"""
        return len(self.agents)

    def get_type_count(self, agent_type: AgentType) -> int:
        """获取特定类型Agent数量"""
        return len(self.agent_types.get(agent_type, []))

    def is_agent_registered(self, agent_id: str) -> bool:
        """检查Agent是否已注册"""
        return agent_id in self.agents

    def _validate_agent(self, agent: BaseAgent) -> bool:
        """验证Agent"""
        # 检查必需属性
        if not hasattr(agent, 'agent_id') or not agent.agent_id:
            return False

        if not hasattr(agent, 'agent_type') or not isinstance(agent.agent_type, AgentType):
            return False

        if not hasattr(agent, 'analyze') or not callable(agent.analyze):
            return False

        if not hasattr(agent, 'communicate') or not callable(agent.communicate):
            return False

        return True
```

### 开发工作流程
1. 设计Agent基础架构和接口规范
2. 实现Agent基类和抽象方法
3. 创建Agent注册和发现机制
4. 设计Agent间通信协议
5. 实现状态管理和上下文传递
6. 创建配置管理和参数调优系统
7. 编写单元测试和集成测试
8. 验证Agent框架的扩展性和性能

### 依赖关系说明
- 依赖Epic 1完成的基础框架
- 为Epic 2的其他Agent故事提供基础架构
- 为后续业务逻辑开发提供Agent基础

### 重要注意事项
- Agent接口设计需要考虑可扩展性
- 通信协议需要支持异步和并发处理
- 状态管理需要考虑线程安全和数据一致性
- 配置管理需要支持热更新和版本控制
- 注册机制需要支持动态添加和移除

### 性能优化建议
- Agent实例池化减少创建销毁开销
- 消息队列实现异步处理提高吞吐量
- 状态缓存减少数据库查询开销
- 配置缓存减少文件读取开销
- 通信传输层优化减少网络延迟

### Testing

#### 测试标准
- 测试文件位置: tests/agent_framework/目录
- 基础架构测试: 验证Agent基类功能
- 通信测试: 验证Agent间通信功能
- 状态管理测试: 验证状态转换逻辑
- 配置管理测试: 验证配置加载和更新

#### 测试框架和模式
- 单元测试: pytest + asyncio测试
- 集成测试: pytest + pytest-asyncio
- 通信测试: pytest + mock
- 性能测试: pytest + pytest-benchmark

#### 特定测试要求
- 所有Agent接口需要测试
- 状态转换需要测试所有有效和无效转换
- 通信协议需要测试各种消息类型
- 配置管理需要测试加载、更新和缓存
- 注册机制需要测试动态添加和移除

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-20 | 1.0 | 初始故事创建 | John (PM) |

## Dev Agent Record

### Agent Model Used
(待开发时填写)

### Debug Log References
(待开发时填写)

### Completion Notes List
(待开发时填写)

### File List
(待开发时填写)

## QA Results
(待QA测试时填写)