# Story 2.2: S-Agent (战略家) 实现

## Status
Draft

## Story

**As a** 系统用户,
**I want** S-Agent能够分析应急场景并生成战略框架,
**so that** 获得高层次的决策指导和优先级建议。

## Acceptance Criteria

1. S-Agent能够解析应急场景信息(事件类型、规模、环境等)
2. 基于场景信息生成初步战略框架
3. 提供行动优先级排序和关键决策点识别
4. 输出结构化的战略建议(格式化JSON)
5. 支持战略方案的迭代优化和调整

## Tasks / Subtasks

- [ ] 实现S-Agent核心功能 (AC: #1)
  - [ ] 创建S-Agent类继承BaseAgent
    - [ ] 实现__init__初始化方法
    - [ ] 配置S-Agent特定的配置参数
    - [ ] 设置大模型连接和参数
    - [ ] 初始化战略分析工具集
  - [ ] 实现场景信息解析功能
    - [ ] 解析应急事件基本信息(类型、时间、地点)
    - [ ] 提取环境参数(天气、地形、人口等)
    - [ ] 分析事件规模和影响范围
    - [ ] 识别关键风险因素
  - [ ] 设计场景信息提取器
    - [ ] 基础信息提取器(从结构化数据)
    - [ ] 自然语言信息提取器(从文本描述)
    - [ ] 地理信息提取器(从GIS数据)
    - [ ] 多源数据融合处理器
  - [ ] 创建场景理解模块
    - [ ] 场景类型识别和分类
    - [ ] 严重程度评估算法
    - [ ] 紧急程度分析逻辑
    - [ ] 影响范围预测模型
  - [ ] 实现场景验证功能
    - [ ] 数据完整性检查
    - [ ] 逻辑一致性验证
    - [ ] 异常数据识别和处理
    - [ ] 场景合理性评估

- [ ] 实现战略框架生成 (AC: #2)
  - [ ] 设计战略分析引擎
    - [ ] 战略要素识别算法
    - [ ] 目标分解机制
    - [ ] 优先级评估体系
    - [ ] 决策点识别逻辑
  - [ ] 创建战略模板库
    - [ ] 不同灾害类型的战略模板
    -   不同规模的响应模板
    - [ ] 不同环境的战略模板
    - [ ] 可配置的战略框架模板
  - [ ] 实现战略生成算法
    - [ ] 基于场景匹配战略模板
    - [ ] 动态调整战略要素
    - [ ] 生成多层次战略目标
    - [ ] 创建战略执行时间表
  - [ ] 设计战略验证机制
    - [ ] 战略逻辑一致性检查
    - [ ] 可行性评估算法
    - [ ] 风险收益平衡分析
    - [ ] 战略方案优化建议
  - [ ] 创建战略优化器
    - [ ] 多方案对比分析
    - [ ] 战略方案迭代优化
    - [ ] 动态调整机制
    - [ ] 反馈学习和改进

- [ ] 实现优先级和决策点识别 (AC: #3)
  - [ ] 设计优先级评估模型
    - [ ] 多维度权重体系(生命安全、基础设施、环境等)
    -   动态权重调整机制
    - [ ] 风险等级影响因子
    -   时间窗口约束考虑
  - [ ] 实现优先级排序算法
    - [ ] 基于权重的排序算法
    -   基于时间紧迫度的调整
    - [ ] 基于资源约束的优化
    - [ ] 实时优先级更新机制
  - [ ] 创建决策点识别系统
    - [ ] 关键决策节点检测
    - [ ] 决策时机分析算法
    - [ ] 决策路径规划器
    -   决策依赖关系分析
  - [ ] 实现决策支持工具
    - [ ] 决策树构建算法
    - [ ] 影响力评估模型
    - [ ] 不确定性分析方法
    -   决策建议生成器
  - [ ] 创建优先级可视化
    - [ ] 优先级矩阵可视化
    -   决策路径可视化
    -   时间轴可视化
    - 实时更新机制

- [ ] 实现结构化战略输出 (AC: #4)
  - [ ] 设计战略数据模型
    - [ ] StrategicFramework数据结构
    - [ ] StrategicGoal目标结构
    - [ ] ActionPlan行动计划结构
    - [ ] DecisionPoint决策点结构
  - [ ] 实现JSON格式化输出
    - [ ] 标准JSON格式定义
    - [ ] 数据序列化和反序列化
    - [ ] 版本控制和兼容性
    - [ ] 错误处理和验证
  - [ ] 创建多格式输出支持
    - [ ] JSON格式(主要)
    - [ ] XML格式(兼容性)
    - [ ] Markdown格式(可读性)
    - [ ] 自定义格式扩展
  - [ ] 实现输出验证机制
    - [ ] 数据完整性验证
    - [ ] 格式规范检查
    - [ ] 内容合理性验证
    - [ ] 自动化测试覆盖
  - [ ] 创建输出可视化工具
    - [ ] 战略框架可视化组件
    - [ ] 优先级可视化图表
    - [ ] 决策路径可视化
    - [ ] 导出报告生成器

- [ ] 实现迭代优化机制 (AC: #5)
  - [ ] 设计反馈收集系统
    - [ ] 用户反馈收集接口
    - [ ] 执行结果反馈分析
    - [ ] 专家意见整合机制
    - [ ] 反馈数据标准化
  - [ ] 实现学习能力
    - [ ] 战略效果评估算法
    - [ ] 经验学习和模式识别
    - [ ] 知识库更新机制
    - [ ] 自适应优化算法
  - [ ] 创建优化迭代器
    - [ ] 基于反馈的战略调整
    - [ ] 多方案对比分析
    - [ ] 增量优化机制
    - [ ] 版本控制管理
  - [ ] 实现持续改进机制
    - [ ] A/B测试框架
    - [ ] 效果评估指标体系
    - [ ] 持续监控和报告
    - [ ] 自动化优化流程
  - [ ] 创建优化评估系统
    - [ ] 优化效果量化评估
    - [ ] 改进方向识别
    - [ ] ROI分析工具
    - [ ] 优化建议生成

## Dev Notes

### 技术架构信息
S-Agent作为战略分析的核心智能体，采用以下技术栈：
- AI框架: AutoGen + DeepSeek V3 (本地部署优先)
- 数据处理: Pandas + NumPy (数据分析)
- 决策算法: 自定义优先级算法 + 权重体系
- 输出格式: JSON + 多格式支持
- 学习机制: 基于反馈的优化算法

### S-Agent核心设计
```python
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import json
import asyncio
import time
from datetime import datetime, timedelta

class SeverityLevel(Enum):
    """严重程度枚举"""
    LOW = 1      # 低风险
    MEDIUM = 2   # 中等风险
    HIGH = 3     # 高风险
    CRITICAL = 4 # 极高风险

class PriorityDimension(Enum):
    """优先级维度"""
    LIFE_SAFETY = "life_safety"      # 生命安全
    INFRASTRUCTURE = "infrastructure"  # 基础设施
    ENVIRONMENT = "environment"      # 环境
    SOCIAL_STABILITY = "social_stability"  # 社会稳定
    ECONOMIC_IMPACT = "economic_impact"  # 经济影响

@dataclass
class EmergencyScenario:
    """应急场景数据模型"""
    scenario_id: str
    event_type: str
    severity: SeverityLevel
    location: Dict[str, Any]
    time_info: Dict[str, Any]
    environment_data: Dict[str, Any]
    population_data: Dict[str, Any]
    infrastructure_data: Dict[str, Any]
    risk_factors: List[Dict[str, Any]]
    raw_data: Dict[str, Any]
    created_at: datetime

@dataclass
class StrategicFramework:
    """战略框架数据模型"""
    framework_id: str
    scenario_id: str
    analysis_timestamp: datetime
    overall_strategy: str
    strategic_goals: List[Dict[str, Any]]
    action_priorities: List[Dict[str, Any]]
    decision_points: List[Dict[str, Any]]
    risk_assessment: Dict[str, Any]
    resource_requirements: Dict[str, Any]
    timeline: Dict[str, Any]
    confidence_score: float
    recommendations: List[Dict[str, Any]]

class SAgent(BaseAgent):
    """S-Agent (战略家) 实现"""

    def __init__(self, agent_id: str, config: Dict[str, Any]):
        super().__init__(agent_id, AgentType.S_AGENT, config)

        # S-Agent特定配置
        self.max_analysis_time = config.get('max_analysis_time', 30.0)
        self.min_confidence_score = config.get('min_confidence_score', 0.7)
        self.enable_learning = config.get('enable_learning', True)

        # 组件初始化
        self.scenario_parser = ScenarioParser()
        self.strategy_generator = StrategyGenerator()
        self.priority_evaluator = PriorityEvaluator()
        self.output_formatter = OutputFormatter()
        self.optimization_engine = OptimizationEngine()

        # 知识库
        self.strategy_templates = self._load_strategy_templates()
        self.case_studies = self._load_case_studies()
        self.expert_rules = self._load_expert_rules()

    async def analyze(self, scenario_data: Dict[str, Any]) -> Dict[str, Any]:
        """分析应急场景"""
        start_time = time.time()

        try:
            # 步骤1: 解析场景信息
            scenario = await self.scenario_parser.parse_scenario(scenario_data)

            # 步骤2: 生成战略框架
            framework = await self.strategy_generator.generate_framework(
                scenario, self.strategy_templates
            )

            # 步骤3: 评估优先级
            priorities = await self.priority_evaluator.evaluate_priorities(
                scenario, framework
            )

            # 步骤4: 整合分析结果
            result = {
                'scenario': scenario,
                'framework': framework,
                'priorities': priorities,
                'analysis_time': time.time() - start_time,
                'confidence_score': self._calculate_confidence(framework),
                'recommendations': self._generate_recommendations(framework, priorities)
            }

            return result

        except Exception as e:
            logger.error(f"S-Agent analysis failed: {e}")
            raise

    async def communicate(self, message: AgentMessage) -> Optional[AgentMessage]:
        """通信方法"""
        try:
            if message.message_type == "STRATEGY_REQUEST":
                return await self._handle_strategy_request(message)
            elif message.message_type == "OPTIMIZATION_REQUEST":
                return await self._handle_optimization_request(message)
            elif message.message_type == "FEEDBACK_PROVIDED":
                return await self._handle_feedback(message)
            else:
                return None
        except Exception as e:
            logger.error(f"S-Agent communication failed: {e}")
            return None

    async def update_state(self, new_state: AgentState) -> bool:
        """状态更新方法"""
        return await super().update_state(new_state)

    def _calculate_confidence(self, framework: StrategicFramework) -> float:
        """计算置信度评分"""
        try:
            scores = []

            # 基础数据质量评分
            data_quality_score = self._assess_data_quality(framework)
            scores.append(data_quality_score)

            # 逻辑一致性评分
            consistency_score = self._assess_logical_consistency(framework)
            scores.append(consistency_score)

            # 可行性评分
            feasibility_score = self._assess_feasibility(framework)
            scores.append(feasibility_score)

            # 经验一致性评分
            experience_score = self._assess_experience_consistency(framework)
            scores.append(experience_score)

            # 计算综合置信度
            confidence = sum(scores) / len(scores)

            # 确保不低于最低阈值
            return max(confidence, self.min_confidence_score)

        except Exception as e:
            logger.error(f"Failed to calculate confidence: {e}")
            return self.min_confidence_score

    def _generate_recommendations(self, framework: StrategicFramework,
                                  priorities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """生成建议"""
        recommendations = []

        try:
            # 基于分析结果的建议
            if framework.confidence_score < 0.8:
                recommendations.append({
                    'type': 'confidence_improvement',
                    'priority': 'high',
                    'description': '建议收集更多信息以提高分析置信度',
                    'actions': ['获取更多实时数据', '咨询专家意见', '参考历史案例']
                })

            # 基于优先级的建议
            high_priority_items = [p for p in priorities if p.get('priority_score', 0) >= 0.8]
            if high_priority_items:
                recommendations.append({
                    'type': 'urgent_action',
                    'priority': 'high',
                    'description': f'发现{len(high_priority_items)}个高优先级行动项',
                    'actions': [item['description'] for item in high_priority_items]
                })

            # 基于风险的建议
            if framework.risk_assessment.get('overall_risk', 0) >= 0.7:
                recommendations.append({
                    'type': 'risk_mitigation',
                    'priority': 'high',
                    'description': '整体风险等级较高，需要加强风险控制',
                    'actions': ['制定详细风险应对预案', '加强监测预警', '准备应急资源']
                })

        except Exception as e:
            logger.error(f"Failed to generate recommendations: {e}")

        return recommendations

    def _load_strategy_templates(self) -> Dict[str, Dict[str, Any]]:
        """加载战略模板"""
        # 这里应该从配置文件或数据库加载
        # 暂时返回空字典，实际实现时需要完善
        return {}

    def _load_case_studies(self) -> List[Dict[str, Any]]:
        """加载案例研究"""
        # 这里应该从数据库或文件系统加载
        # 暂时返回空列表，实际实现时需要完善
        return []

    def _load_expert_rules(self) -> List[Dict[str, Any]]:
        """加载专家规则"""
        # 这里应该从配置文件或知识库加载
        # 暂时返回空列表，实际实现时需要完善
        return []

class ScenarioParser:
    """场景解析器"""

    def __init__(self):
        self.parsers = {
            'basic_info': BasicInfoParser(),
            'environment': EnvironmentParser(),
            'geographic': GeographicParser(),
            'risk_factors': RiskFactorParser()
        }

    async def parse_scenario(self, scenario_data: Dict[str, Any]) -> EmergencyScenario:
        """解析应急场景"""
        try:
            # 生成场景ID
            scenario_id = self._generate_scenario_id(scenario_data)

            # 解析基本信息
            basic_info = await self.parsers['basic_info'].parse(scenario_data)

            # 解析环境数据
            environment_data = await self.parsers['environment'].parse(scenario_data)

            # 解析地理信息
            location_data = await self.parsers['geographic'].parse(scenario_data)

            # 解析风险因素
            risk_factors = await self.parsers['risk_factors'].parse(scenario_data)

            # 确定严重程度
            severity = self._determine_severity(basic_info, risk_factors)

            return EmergencyScenario(
                scenario_id=scenario_id,
                event_type=basic_info.get('event_type', 'unknown'),
                severity=severity,
                location=location_data,
                time_info=basic_info.get('time_info', {}),
                environment_data=environment_data,
                population_data=basic_info.get('population_data', {}),
                infrastructure_data=basic_info.get('infrastructure_data', {}),
                risk_factors=risk_factors,
                raw_data=scenario_data,
                created_at=datetime.now()
            )

        except Exception as e:
            logger.error(f"Failed to parse scenario: {e}")
            raise

    def _generate_scenario_id(self, scenario_data: Dict[str, Any]) -> str:
        """生成场景ID"""
        # 基于事件类型和时间戳生成ID
        event_type = scenario_data.get('event_type', 'unknown')
        timestamp = int(time.time())
        return f"{event_type}_{timestamp}"

    def _determine_severity(self, basic_info: Dict[str, Any],
                            risk_factors: List[Dict[str, Any]]) -> SeverityLevel:
        """确定严重程度"""
        # 基于风险因素和基本信息确定严重程度
        max_risk_level = 0

        for risk_factor in risk_factors:
            risk_level = risk_factor.get('risk_level', 1)
            if risk_level > max_risk_level:
                max_risk_level = risk_level

        # 基于事件类型调整严重程度
        event_type = basic_info.get('event_type', '').lower()
        if 'flood' in event_type or 'earthquake' in event_type:
            max_risk_level = max(max_risk_level, 3)
        elif 'fire' in event_type:
            max_risk_level = max(max_risk_level, 2)

        return SeverityLevel(max_risk_level)

class StrategyGenerator:
    """战略生成器"""

    def __init__(self):
        self.framework_builder = FrameworkBuilder()
        self.goal_analyzer = GoalAnalyzer()
        self.timeline_planner = TimelinePlanner()

    async def generate_framework(self, scenario: EmergencyScenario,
                                 templates: Dict[str, Any]) -> StrategicFramework:
        """生成战略框架"""
        try:
            # 选择合适的模板
            template = self._select_template(scenario, templates)

            # 分析场景特征
            analysis = self._analyze_scenario_characteristics(scenario)

            # 生成战略目标
            goals = await self.goal_analyzer.analyze_goals(scenario, analysis)

            # 制定时间计划
            timeline = await self.timeline_planner.create_timeline(scenario, goals)

            # 构建框架
            framework = await self.framework_builder.build_framework(
                scenario=scenario,
                template=template,
                analysis=analysis,
                goals=goals,
                timeline=timeline
            )

            return framework

        except Exception as e:
            logger.error(f"Failed to generate framework: {e}")
            raise

    def _select_template(self, scenario: EmergencyScenario,
                           templates: Dict[str, Any]) -> Dict[str, Any]:
        """选择合适的模板"""
        # 基于事件类型和严重程度选择模板
        event_type = scenario.event_type
        severity = scenario.severity

        # 查找匹配的模板
        matching_templates = []
        for template_id, template_data in templates.items():
            if template_id.startswith(event_type):
                if self._is_template_suitable(template_data, severity):
                    matching_templates.append((template_id, template_data))

        # 如果没有找到匹配的模板，使用默认模板
        if not matching_templates:
            return templates.get('default', {})

        # 选择最合适的模板
        return max(matching_templates, key=lambda x: x[1].get('priority', 0))[1]

    def _is_template_suitable(self, template: Dict[str, Any],
                           severity: SeverityLevel) -> bool:
        """判断模板是否适合当前严重程度"""
        template_severity_range = template.get('severity_range', [SeverityLevel.LOW, SeverityLevel.CRITICAL])
        return template_severity_range[0] <= severity <= template_severity_range[1]

    def _analyze_scenario_characteristics(self, scenario: EmergencyScenario) -> Dict[str, Any]:
        """分析场景特征"""
        return {
            'event_type': scenario.event_type,
            'severity': scenario.severity,
            'location_type': self._analyze_location_type(scenario.location),
            'time_pressure': self._analyze_time_pressure(scenario.time_info),
            'resource_constraints': self._analyze_resource_constraints(scenario),
            'environmental_factors': self._analyze_environmental_factors(scenario.environment_data)
        }

    def _analyze_location_type(self, location: Dict[str, Any]) -> str:
        """分析位置类型"""
        # 基于地理位置特征判断位置类型
        if 'urban' in str(location).lower():
            return 'urban'
        elif 'rural' in str(location).lower():
            return 'rural'
        elif 'industrial' in str(location).lower():
            return 'industrial'
        else:
            return 'mixed'

    def _analyze_time_pressure(self, time_info: Dict[str, Any]) -> str:
        """分析时间压力"""
        # 基于时间信息分析时间压力
        if 'urgency' in str(time_info).lower():
            return 'high'
        elif 'immediate' in str(time_info).lower():
            return 'medium'
        else:
            return 'low'

    def _analyze_resource_constraints(self, scenario: EmergencyScenario) -> str:
        """分析资源约束"""
        # 基于人口和基础设施分析资源约束
        population = scenario.population_data.get('affected_population', 0)
        infrastructure = scenario.infrastructure_data.get('affected_infrastructure', [])

        if population > 100000 or len(infrastructure) > 10:
            return 'high'
        elif population > 10000 or len(infrastructure) > 5:
            return 'medium'
        else:
            return 'low'

    def _analyze_environmental_factors(self, environment_data: Dict[str, Any]) -> List[str]:
        """分析环境因素"""
        factors = []

        # 检查关键环境因素
        if 'weather' in environment_data:
            factors.append('weather_conditions')
        if 'terrain' in environment_data:
            factors.append('terrain_challenges')
        if 'accessibility' in environment_data:
            factors.append('accessibility_issues')
        if 'communication' in environment_data:
            factors.append('communication_challenges')

        return factors
```

### 开发工作流程
1. 接收应急场景数据
2. 解析场景信息和环境参数
3. 匹配合适的战略模板
4. 生成多层次战略目标
5. 评估行动优先级
6. 识别关键决策点
7. 生成结构化战略建议
8. 提供优化建议

### 依赖关系说明
- 依赖Story 2.1完成的Agent基础框架
- 为Story 2.3 A-Agent提供战略输入
- 为Story 2.5 E-Agent提供战略指导
- 为整个Epic提供战略分析基础

### 重要注意事项
- S-Agent的分析质量直接影响决策质量
- 战略模板需要持续更新和优化
- 优先级评估需要考虑多维度因素
- 输出格式需要标准化和可解析
- 学习机制需要保护用户隐私

### 测试策略
- 单元测试: 测试各个组件的功能正确性
- 集成测试: 测试完整的分析流程
- 端到端测试: 使用真实场景数据测试
- 性能测试: 测试分析时间和资源消耗

### Testing

#### 测试标准
- 测试文件位置: tests/s_agent/目录
- 场景解析测试: 验证各种数据源解析
- 战略生成测试: 验证框架生成逻辑
- 优先级评估测试: 验证权重和算法正确性
- 输出格式测试: 验证JSON格式和内容

#### 测试框架和模式
- 单元测试: pytest + pytest-asyncio
- 模拟测试: pytest + unittest.mock
- 集成测试: pytest + 测试数据集
- 性能测试: pytest + pytest-benchmark

#### 特定测试要求
- 各种事件类型场景的解析测试
- 不同严重程度的战略生成测试
- 优先级算法的准确性验证
- 输出格式的规范性检查
- 迭代优化功能的有效性测试

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-20 | 1.0 | 初始故事创建 | John (PM) |

## Dev Agent Record

### Agent Model Used
(待开发时填写)

### Debug Log References
(待开发时填写)

### Completion Notes List
(待开发时填写)

### File List
(待开发时填写)

## QA Results
(待QA测试时填写)