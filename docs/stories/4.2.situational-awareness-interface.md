# Story 4.2: 态势感知大屏界面开发

## Status
Draft

## Story

**As a** 现场指挥官,
**I want** 一个综合态势感知大屏界面,
**so that** 能够直观地了解灾害态势、实时数据变化和救援进展。

## Acceptance Criteria

1. 态势感知大屏能够展示基于GIS的综合地图
2. 实时显示多维度数据流和关键指标
3. 支持多图层管理和信息叠加
4. 提供交互式数据探索和筛选功能
5. 实现大屏显示优化和全屏模式

## Tasks / Subtasks

- [ ] 实现GIS地图可视化 (AC: #1)
  - [ ] 设计地图组件架构
    - [ ] 地图引擎选择
    - [ ] 图层管理系统
    - [ ] 坐标系统配置
    - [ ] 地图交互控制
  - [ ] 实现基础地理信息层
    - [ ] 地形地貌显示
    - [ ] 行政区划展示
    - [ ] 交通网络显示
    - [ ] 水系分布展示
  - [ ] 创建灾害影响范围层
    - [ ] 影响区域绘制
    - [ ] 风险等级显示
    - [ ] 动态范围变化
    - [ ] 影响统计信息
  - [ ] 实现救援部署图层
    - [ ] 救援队伍位置
    - [ ] 资源投放点标记
    - [ ] 救援路线规划
    - [ ] 调度指令显示
  - [ ] 设计地图交互功能
    - [ ] 缩放平移控制
    - [ ] 图层开关控制
    - [ ] 点击信息显示
    - [ ] 测量工具集成

- [ ] 实现实时数据可视化 (AC: #2)
  - [ ] 设计数据面板布局
    - [ ] 面板组件架构
    - [ ] 响应式布局
    - [ ] 拖拽调整功能
    - [ ] 折叠展开控制
  - [ ] 实现水文数据展示
    - [ ] 水位实时曲线
    - [ ] 流量变化图表
    - [ ] 预警阈值标识
    - [ ] 历史对比分析
  - [ ] 创建天气环境信息
    - [ ] 实时天气显示
    - [ ] 风向风速展示
    - [ ] 降雨量统计
    - [ ] 环境参数监测
  - [ ] 实现人员安全监控
    - [ ] 人员分布热力图
    - [ ] 撤离进度显示
    - [ ] 安全区域标识
    - [ ] 人员统计信息
  - [ ] 设计资源消耗监控
    - [ ] 物资消耗统计
    - [ ] 装备使用情况
    - [ ] 资源调度状态
    - [ ] 补给需求提示

- [ ] 实现多图层管理系统 (AC: #3)
  - [ ] 设计图层管理器
    - [ ] 图层树形结构
    - [ ] 图层权限控制
    - [ ] 图层显示配置
    - [ ] 图层状态同步
  - [ ] 实现图层叠加算法
    - [ ] 图层渲染顺序
    - [ ] 透明度控制
    - [ ] 混合模式设置
    - [ ] 缓存优化机制
  - [ ] 创建图层样式管理
    - [ ] 样式模板系统
    - [ ] 动态样式配置
    - [ ] 条件样式规则
    - [ ] 自定义符号库
  - [ ] 实现图层交互功能
    - [ ] 图层切换动画
    - [ ] 图层关联高亮
    - [ ] 图层数据钻取
    - [ ] 图层时间控制
  - [ ] 设计图层性能优化
    - [ ] 图层懒加载
    - [ ] 数据级别控制
    - [ ] 渲染优化策略
    - [ ] 内存管理机制

- [ ] 实现交互式数据探索 (AC: #4)
  - [ ] 设计数据筛选器
    - [ ] 多条件筛选界面
    - [ ] 筛选条件组合
    - [ ] 筛选历史记录
    - [ ] 快速筛选预设
  - [ ] 实现数据查询功能
    - [ ] 空间查询工具
    - [ ] 属性查询功能
    - [ ] 统计查询分析
    - [ ] 查询结果导出
  - [ ] 创建数据钻取功能
    - [ ] 多层级数据展示
    - [ ] 钻取路径记录
    - [ ] 关联数据跳转
    - [ ] 返回路径管理
  - [ ] 实现数据对比分析
    - [ ] 时间段对比
    - [ ] 区域对比
    - [ ] 指标对比
    - [ ] 差异可视化
  - [ ] 设计自定义视图
    - [ ] 视图保存功能
    - [ ] 视图分享机制
    - [ ] 视图模板管理
    - [ ] 个性化配置

- [ ] 实现大屏显示优化 (AC: #5)
  - [ ] 设计大屏布局系统
    - [ ] 大屏分辨率适配
    - [ ] 布局模板系统
    - [ ] 自适应布局算法
    - [ ] 多屏幕支持
  - [ ] 实现显示优化算法
    - [ ] 字体尺寸自适应
    - [ ] 图表分辨率优化
    - [ ] 颜色对比度增强
    - [ ] 动画性能优化
  - [ ] 创建全屏控制功能
    - [ ] 全屏切换控制
    - [ ] 工具栏隐藏显示
    - [ ] 快捷键操作
    - [ ] 多显示器支持
  - [ ] 实现数据刷新策略
    - [ ] 智能刷新频率
    - [ ] 增量数据更新
    - [ ] 网络状态适配
    - [ ] 缓存控制机制
  - [ ] 设计性能监控系统
    - [ ] 渲染性能监控
    - [ ] 内存使用监控
    - [ ] 网络延迟监控
    - [ ] 异常状态报警

## Dev Notes

### 技术架构信息
态势感知大屏界面采用以下技术栈：
- 地图引擎: Mapbox GL JS + Leaflet
- 数据可视化: ECharts + D3.js + Three.js
- 前端框架: React 18 + TypeScript
- 状态管理: Redux Toolkit + RTK Query
- 实时通信: Socket.IO Client
- 大屏适配: CSS Grid + Flexbox

### 态势感知大屏核心设计
```typescript
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Map } from 'mapbox-gl';
import { Card, Row, Col, Switch, Slider, Button, Tooltip } from 'antd';
import { useWebSocket } from '../hooks/useWebSocket';
import { useAppSelector, useAppDispatch } from '../hooks/redux';
import { updateLayers, updateDataFilters } from '../store/slices/situationalSlice';
import { LayerManager } from '../components/LayerManager';
import { RealTimeDataPanel } from '../components/RealTimeDataPanel';
import { MapControls } from '../components/MapControls';
import { FullscreenControl } from '../components/FullscreenControl';

interface SituationalAwarenessProps {
  eventId: string;
  isFullscreen?: boolean;
}

interface MapLayer {
  id: string;
  name: string;
  type: 'base' | 'overlay' | 'data';
  visible: boolean;
  opacity: number;
  zIndex: number;
  data?: any;
  style?: any;
}

interface DataFilter {
  type: string;
  field: string;
  operator: 'eq' | 'gt' | 'lt' | 'in' | 'between';
  value: any;
  label: string;
}

const SituationalAwareness: React.FC<SituationalAwarenessProps> = ({
  eventId,
  isFullscreen = false
}) => {
  const dispatch = useAppDispatch();
  const {
    mapLayers,
    dataFilters,
    realTimeData,
    selectedFeatures,
    mapCenter,
    mapZoom
  } = useAppSelector(state => state.situational);

  // 地图实例引用
  const mapContainer = useRef<HTMLDivElement>(null);
  const mapInstance = useRef<Map | null>(null);

  // WebSocket连接
  const { data: wsData, isConnected } = useWebSocket(`/situational/${eventId}`);

  // 本地状态
  const [showLayerPanel, setShowLayerPanel] = useState(true);
  const [showDataPanel, setShowDataPanel] = useState(true);
  const [activeTool, setActiveTool] = useState<string | null>(null);

  // 初始化地图
  useEffect(() => {
    if (mapContainer.current && !mapInstance.current) {
      mapInstance.current = new Map({
        container: mapContainer.current,
        style: 'mapbox://styles/mapbox/streets-v11',
        center: mapCenter,
        zoom: mapZoom,
        minZoom: 3,
        maxZoom: 18
      });

      // 添加地图控件
      mapInstance.current.addControl(new mapboxgl.NavigationControl(), 'top-right');
      mapInstance.current.addControl(new mapboxgl.ScaleControl(), 'bottom-left');

      // 绑定地图事件
      mapInstance.current.on('load', handleMapLoad);
      mapInstance.current.on('click', handleMapClick);
      mapInstance.current.on('move', handleMapMove);
    }

    return () => {
      if (mapInstance.current) {
        mapInstance.current.remove();
        mapInstance.current = null;
      }
    };
  }, []);

  // 处理地图加载完成
  const handleMapLoad = useCallback(() => {
    // 加载基础图层
    loadBaseLayers();

    // 加载数据图层
    loadDataLayers();

    // 设置初始视图
    if (mapInstance.current) {
      mapInstance.current.flyTo({
        center: mapCenter,
        zoom: mapZoom,
        essential: true
      });
    }
  }, [mapCenter, mapZoom]);

  // 处理地图点击
  const handleMapClick = useCallback((e: mapboxgl.MapMouseEvent) => {
    const features = mapInstance.current?.queryRenderedFeatures(e.point);

    if (features && features.length > 0) {
      // 处理要素选择
      dispatch({
        type: 'situational/setSelectedFeatures',
        payload: features
      });

      // 显示要素详情
      showFeatureDetails(features[0]);
    }
  }, []);

  // 处理地图移动
  const handleMapMove = useCallback(() => {
    if (mapInstance.current) {
      const center = mapInstance.current.getCenter();
      const zoom = mapInstance.current.getZoom();

      dispatch({
        type: 'situational/updateMapView',
        payload: {
          center: [center.lng, center.lat],
          zoom
        }
      });
    }
  }, []);

  // 加载基础图层
  const loadBaseLayers = useCallback(() => {
    if (!mapInstance.current) return;

    // 添加地形图层
    mapInstance.current.addLayer({
      id: 'terrain',
      type: 'terrain',
      source: 'mapbox-dem',
      layout: {},
      paint: {
        'terrain-exaggeration': 0.5
      }
    });

    // 添加行政区划图层
    mapInstance.current.addSource('administrative', {
      type: 'vector',
      url: 'mapbox://mapbox.mapbox-streets-v8'
    });

    mapInstance.current.addLayer({
      id: 'administrative-boundaries',
      type: 'line',
      source: 'administrative',
      'source-layer': 'admin',
      layout: {},
      paint: {
        'line-color': '#FF0000',
        'line-width': 1
      }
    });
  }, []);

  // 加载数据图层
  const loadDataLayers = useCallback(() => {
    if (!mapInstance.current) return;

    // 加载灾害影响范围
    mapInstance.current.addSource('disaster-affected-area', {
      type: 'geojson',
      data: realTimeData.disasterArea
    });

    mapInstance.current.addLayer({
      id: 'disaster-area-layer',
      type: 'fill',
      source: 'disaster-affected-area',
      paint: {
        'fill-color': '#FF0000',
        'fill-opacity': 0.3
      }
    });

    // 加载救援队伍位置
    mapInstance.current.addSource('rescue-teams', {
      type: 'geojson',
      data: realTimeData.rescueTeams
    });

    mapInstance.current.addLayer({
      id: 'rescue-teams-layer',
      type: 'symbol',
      source: 'rescue-teams',
      layout: {
        'icon-image': 'marker-15',
        'icon-size': 1.5,
        'text-field': '{teamName}',
        'text-font': ['Open Sans Regular'],
        'text-size': 12,
        'text-offset': [0, 1.5]
      },
      paint: {
        'text-color': '#000000',
        'text-halo-color': '#FFFFFF',
        'text-halo-width': 1
      }
    });

    // 加载水位监测点
    mapInstance.current.addSource('water-level-stations', {
      type: 'geojson',
      data: realTimeData.waterStations
    });

    mapInstance.current.addLayer({
      id: 'water-stations-layer',
      type: 'circle',
      source: 'water-level-stations',
      paint: {
        'circle-radius': 6,
        'circle-color': [
          'interpolate',
          ['linear'],
          ['get', 'waterLevel'],
          0, '#0000FF',
          16, '#FFFF00',
          18, '#FF0000'
        ],
        'circle-stroke-color': '#FFFFFF',
        'circle-stroke-width': 2
      }
    });
  }, [realTimeData]);

  // 处理图层可见性变化
  const handleLayerVisibilityChange = useCallback((layerId: string, visible: boolean) => {
    if (mapInstance.current) {
      mapInstance.current.setLayoutProperty(
        `${layerId}-layer`,
        'visibility',
        visible ? 'visible' : 'none'
      );

      dispatch({
        type: 'situational/updateLayerVisibility',
        payload: { layerId, visible }
      });
    }
  }, []);

  // 处理图层透明度变化
  const handleLayerOpacityChange = useCallback((layerId: string, opacity: number) => {
    if (mapInstance.current) {
      const layerType = mapInstance.current.getLayer(`${layerId}-layer`)?.type;

      if (layerType === 'fill') {
        mapInstance.current.setPaintProperty(
          `${layerId}-layer`,
          'fill-opacity',
          opacity
        );
      } else if (layerType === 'circle') {
        mapInstance.current.setPaintProperty(
          `${layerId}-layer`,
          'circle-opacity',
          opacity
        );
      } else if (layerType === 'line') {
        mapInstance.current.setPaintProperty(
          `${layerId}-layer`,
          'line-opacity',
          opacity
        );
      }

      dispatch({
        type: 'situational/updateLayerOpacity',
        payload: { layerId, opacity }
      });
    }
  }, []);

  // 处理数据筛选
  const handleDataFilterChange = useCallback((filters: DataFilter[]) => {
    dispatch(updateDataFilters(filters));

    // 重新加载数据图层
    loadDataLayers();
  }, [loadDataLayers]);

  // 处理工具选择
  const handleToolSelect = useCallback((tool: string | null) => {
    setActiveTool(tool);

    // 设置地图交互状态
    if (mapInstance.current) {
      if (tool === 'measure') {
        mapInstance.current.getCanvas().style.cursor = 'crosshair';
      } else if (tool === 'draw') {
        mapInstance.current.getCanvas().style.cursor = 'crosshair';
      } else {
        mapInstance.current.getCanvas().style.cursor = 'grab';
      }
    }
  }, []);

  return (
    <div className={`situational-awareness ${isFullscreen ? 'fullscreen' : ''}`}>
      {/* 地图容器 */}
      <div ref={mapContainer} className="map-container" />

      {/* 地图控件 */}
      <div className="map-controls">
        <MapControls
          tools={['measure', 'draw', 'select', 'pan']}
          activeTool={activeTool}
          onToolSelect={handleToolSelect}
        />
        <FullscreenControl
          isFullscreen={isFullscreen}
          onToggle={() => {/* 处理全屏切换 */}}
        />
      </div>

      {/* 图层面板 */}
      <div className={`layer-panel ${showLayerPanel ? 'visible' : 'hidden'}`}>
        <LayerManager
          layers={mapLayers}
          onVisibilityChange={handleLayerVisibilityChange}
          onOpacityChange={handleLayerOpacityChange}
          onFilterChange={handleDataFilterChange}
        />
        <Button
          className="panel-toggle"
          onClick={() => setShowLayerPanel(!showLayerPanel)}
        >
          {showLayerPanel ? '隐藏' : '显示'}图层面板
        </Button>
      </div>

      {/* 实时数据面板 */}
      <div className={`data-panel ${showDataPanel ? 'visible' : 'hidden'}`}>
        <RealTimeDataPanel
          data={realTimeData}
          filters={dataFilters}
          onFilterChange={handleDataFilterChange}
          onFeatureSelect={(feature) => {/* 处理要素选择 */}}
        />
        <Button
          className="panel-toggle"
          onClick={() => setShowDataPanel(!showDataPanel)}
        >
          {showDataPanel ? '隐藏' : '显示'}数据面板
        </Button>
      </div>

      {/* 选中要素详情 */}
      {selectedFeatures.length > 0 && (
        <div className="feature-details">
          <Card
            title="要素详情"
            size="small"
            extra={
              <Button
                type="text"
                onClick={() => dispatch({ type: 'situational/clearSelectedFeatures' })}
              >
                ×
              </Button>
            }
          >
            {/* 渲染要素详情内容 */}
            {selectedFeatures.map((feature, index) => (
              <div key={index}>
                <h4>{feature.layer?.id || '未知图层'}</h4>
                <pre>{JSON.stringify(feature.properties, null, 2)}</pre>
              </div>
            ))}
          </Card>
        </div>
      )}

      {/* 连接状态指示器 */}
      <div className="connection-indicator">
        <Tooltip title={`WebSocket连接: ${isConnected ? '已连接' : '断开'}`}>
          <div className={`status-dot ${isConnected ? 'connected' : 'disconnected'}`} />
        </Tooltip>
      </div>
    </div>
  );
};

export default SituationalAwareness;
```

### 开发工作流程
1. 设计GIS地图组件架构和图层管理系统
2. 实现基础地理信息和灾害影响范围展示
3. 开发实时数据可视化面板和图表组件
4. 构建多图层管理和交互控制系统
5. 实现数据筛选、查询和钻取功能
6. 优化大屏显示性能和用户体验
7. 集成实时数据更新和状态同步
8. 进行全屏模式和多显示器适配测试

### 依赖关系说明
- 依赖Story 4.1主控制台的框架基础
- 需要地图服务API和实时数据推送
- 依赖图表库和可视化组件
- 为其他界面提供态势数据支撑

### 重要注意事项
- 地图渲染需要考虑大数据量的性能优化
- 实时数据更新需要保证性能和流畅度
- 图层管理需要支持复杂的数据叠加关系
- 大屏显示需要适配各种分辨率和设备
- 交互功能需要直观易用的操作体验

### 测试策略
- 单元测试: 测试地图组件和数据面板功能
- 集成测试: 测试图层管理和数据流
- 性能测试: 测试大数据量渲染性能
- 用户体验测试: 验证交互操作的易用性
- 大屏测试: 验证大屏显示效果

### Testing

#### 测试标准
- 测试文件位置: tests/situational/目录
- 地图功能测试: 验证地图交互和图层管理
- 数据可视化测试: 验证图表渲染和数据准确性
- 实时更新测试: 验证数据同步的及时性
- 大屏显示测试: 验证大屏适配和性能

#### 测试框架和模式
- 单元测试: Jest + React Testing Library
- 集成测试: Cypress + 地图Mock
- 性能测试: Lighthouse + WebPageTest
- 可视化回归测试: Percy + Storybook

#### 特定测试要求
- 大数据量地图渲染的性能测试
- 实时数据更新的稳定性测试
- 复杂图层叠加的准确性测试
- 长时间运行的内存泄漏测试
- 多显示器适配的兼容性测试

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-20 | 1.0 | 初始故事创建 | John (PM) |

## Dev Agent Record

### Agent Model Used
(待开发时填写)

### Debug Log References
(待开发时填写)

### Completion Notes List
(待开发时填写)

### File List
(待开发时填写)

## QA Results
(待QA测试时填写)