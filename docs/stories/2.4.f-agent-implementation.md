# Story 2.4: F-Agent (专家) 实现

## Status
Draft

## Story

**As a** 系统用户,
**I want** F-Agent能够基于专业知识对应急场景进行深度分析和评估,
**so that** 获得专业领域的技术指导和专家级决策支持。

## Acceptance Criteria

1. F-Agent能够调用多个专业领域的专家知识库
2. 基于S-Agent战略框架进行专业分析
3. 提供技术可行性评估和专家建议
4. 支持多专家协作和知识融合
5. 输出结构化的专家分析报告

## Tasks / Subtasks

- [ ] 实现F-Agent核心功能 (AC: #1)
  - [ ] 创建FAgent类继承BaseAgent
    - [ ] 实现__init__初始化方法
    - [ ] 配置F-Agent特定参数
    - [ ] 设置专家知识库连接
    - [ ] 初始化专业分析工具集
  - [ ] 设计专家知识管理系统
    - [ ] 知识库结构设计
    - [ ] 知识检索和匹配算法
    - [ ] 知识更新和维护机制
    - [ ] 知识质量评估系统
  - [ ] 实现专家能力调用接口
    - [ ] 多领域专家调度器
    - [ ] 专家能力映射表
    - [ ] 并行专家分析协调器
    - [ ] 专家结果整合器
  - [ ] 创建专业知识提取器
    - [ ] 领域术语提取器
    - [ ] 专业关系识别器
    - [ ] 技术参数分析器
    - [ ] 专业模式匹配器
  - [ ] 实现专家推理引擎
    - [ ] 基于规则的推理系统
    - [ ] 案例推理引擎
    - [ ] 不确定性推理机制
    - [ ] 专家冲突解决器

- [ ] 实现专业分析功能 (AC: #2)
  - [ ] 设计领域分析模块
    - [ ] 地质灾害分析模块
    - [ ] 气象灾害分析模块
    - [ ] 基础设施分析模块
    - [ ] 公共卫生分析模块
  - [ ] 实现技术可行性评估
    - [ ] 技术方案可行性分析器
    - [ ] 资源需求评估器
    - [ ] 时间成本计算器
    - [ ] 风险技术评估器
  - [ ] 创建专家建议生成器
    - [ ] 基于知识的建议生成
    - [ ] 经验驱动的建议生成
    - [ ] 多专家建议融合器
    - [ ] 建议优先级排序器
  - [ ] 实现专业评估模型
    - [ ] 多维度评估指标体系
    - [ ] 权重分配算法
    - [ ] 综合评分计算器
    - [ ] 评估结果校验器
  - [ ] 设计专家协作机制
    - [ ] 专家间通信协议
    - [ ] 协作任务分配器
    - [ ] 协作结果聚合器
    - [ ] 协作质量评估器

- [ ] 实现专家建议输出 (AC: #3)
  - [ ] 设计专家评估框架
    - [ ] 评估维度定义
    - [ ] 评估指标计算
    - [ ] 评估结果标准化
    - [ ] 评估置信度计算
  - [ ] 创建技术可行性分析器
    - [ ] 技术路线分析
    - [ ] 技术难点识别
    - [ ] 技术风险评估
    - [ ] 技术方案推荐
  - [ ] 实现专家建议生成
    - [ ] 建议模板管理器
    - [ ] 建议内容生成器
    - [ ] 建议理由解释器
    - [ ] 建议可行性验证器
  - [ ] 设计建议验证机制
    - [ ] 建议逻辑一致性检查
    - [ ] 建议可行性验证
    - [ ] 建议效果预测
    - [ ] 建议风险评估
  - [ ] 创建专家报告生成器
    - [ ] 报告模板管理
    - [ ] 报告内容组织器
    - [ ] 报告可视化生成器
    - [ ] 报告质量检查器

- [ ] 实现多专家协作 (AC: #4)
  - [ ] 设计专家协作网络
    - [ ] 专家节点管理器
    - [ ] 协作路径规划器
    - [ ] 协作任务调度器
    - [ ] 协作状态监控器
  - [ ] 实现知识融合机制
    - [ ] 异构知识表示转换
    - [ ] 知识冲突检测器
    - [ ] 知识融合算法
    - [ ] 融合质量评估器
  - [ ] 创建协作决策系统
    - [ ] 协作决策流程设计
    - [ ] 决策权重分配算法
    - [ ] 决策一致性检查器
    - [ ] 决策结果聚合器
  - [ ] 实现专家共识机制
    - [ ] 共识识别算法
    - [ ] 共识度计算器
    - [ ] 共识达成策略
    - [ ] 共识结果验证器
  - [ ] 设计协作性能优化
    - [ ] 协作效率评估器
    - [ ] 协作负载均衡器
    - [ ] 协作冲突解决器
    - [ ] 协作质量改进器

- [ ] 实现结构化专家报告 (AC: #5)
  - [ ] 设计专家数据模型
    - [ ] ExpertAnalysis数据结构
    - [ ] ExpertRecommendation建议结构
    - [ ] TechnicalAssessment技术评估结构
    - [ ] ExpertConsensus专家共识结构
  - [ ] 实现JSON格式化输出
    - [ ] 专家分析JSON格式
    - [ ] 建议内容JSON格式
    - [ ] 评估结果JSON格式
    - [ ] 错误处理和验证
  - [ ] 创建多格式输出支持
    - [ ] JSON格式(主要)
    - [ ] 专业报告格式
    - [ ] 简化摘要格式
    - [ ] 可视化图表格式
  - [ ] 实现输出验证机制
    - [ ] 专家建议合理性验证
    - [ ] 技术评估准确性检查
    - [ ] 输出格式规范检查
    - [ ] 自动化测试覆盖
  - [ ] 创建专家可视化工具
    - [ ] 专家分析结果可视化
    - [ ] 技术评估图表生成
    - [ ] 专家建议展示组件
    - [ ] 专业知识图谱可视化

## Dev Notes

### 技术架构信息
F-Agent作为专业知识分析的核心智能体，采用以下技术栈：
- AI框架: AutoGen + 专业领域知识库
- 知识管理: Neo4j图数据库 + 向量数据库
- 推理引擎: 基于规则 + 基于案例 + 混合推理
- 协作机制: 分布式专家网络 + 共识算法
- 输出格式: JSON + 专业报告格式

### F-Agent核心设计
```python
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import json
import asyncio
import time
from datetime import datetime, timedelta
import networkx as nx
from collections import defaultdict

class ExpertiseDomain(Enum):
    """专业领域枚举"""
    GEOLOGICAL = "geological"       # 地质灾害
    METEOROLOGICAL = "meteorological" # 气象灾害
    INFRASTRUCTURE = "infrastructure" # 基础设施
    PUBLIC_HEALTH = "public_health"   # 公共卫生
    ENVIRONMENTAL = "environmental"   # 环境保护
    SECURITY = "security"           # 安全防护
    LOGISTICS = "logistics"         # 物流保障
    COMMUNICATION = "communication"   # 通信保障

class ConfidenceLevel(Enum):
    """置信度等级"""
    VERY_LOW = 1    # 很低
    LOW = 2         # 低
    MEDIUM = 3      # 中等
    HIGH = 4        # 高
    VERY_HIGH = 5   # 很高

@dataclass
class ExpertKnowledge:
    """专家知识数据模型"""
    knowledge_id: str
    domain: ExpertiseDomain
    expertise_type: str
    content: Dict[str, Any]
    confidence: ConfidenceLevel
    source: str
    created_at: datetime
    updated_at: datetime
    tags: Set[str] = field(default_factory=set)
    references: List[str] = field(default_factory=list)
    applicable_scenarios: List[str] = field(default_factory=list)

@dataclass
class ExpertAnalysis:
    """专家分析数据模型"""
    analysis_id: str
    expert_id: str
    domain: ExpertiseDomain
    scenario_id: str
    analysis_timestamp: datetime
    technical_assessment: Dict[str, Any]
    feasibility_evaluation: Dict[str, Any]
    risk_assessment: Dict[str, Any]
    recommendations: List[Dict[str, Any]]
    confidence_level: ConfidenceLevel
    reasoning_chain: List[Dict[str, Any]]
    supporting_evidence: List[Dict[str, Any]]
    limitations: List[str]

@dataclass
class ExpertConsensus:
    """专家共识数据模型"""
    consensus_id: str
    scenario_id: str
    participating_experts: List[str]
    consensus_timestamp: datetime
    consensus_level: float  # 0-1之间，1表示完全共识
    agreed_points: List[Dict[str, Any]]
    disagreed_points: List[Dict[str, Any]]
    consensus_recommendations: List[Dict[str, Any]]
    confidence_distribution: Dict[str, int]
    consensus_quality_score: float

class FAgent(BaseAgent):
    """F-Agent (专家) 实现"""

    def __init__(self, agent_id: str, config: Dict[str, Any]):
        super().__init__(agent_id, AgentType.F_AGENT, config)

        # F-Agent特定配置
        self.max_experts_per_domain = config.get('max_experts_per_domain', 3)
        self.consensus_threshold = config.get('consensus_threshold', 0.7)
        self.enable_collaborative_analysis = config.get('enable_collaborative_analysis', True)
        self.knowledge_update_interval = config.get('knowledge_update_interval', 3600)

        # 组件初始化
        self.expert_manager = ExpertManager()
        self.knowledge_base = KnowledgeBase()
        self.reasoning_engine = ReasoningEngine()
        self.consensus_builder = ConsensusBuilder()
        self.analysis_orchestrator = AnalysisOrchestrator()

        # 专家网络
        self.expert_network = self._initialize_expert_network()
        self.active_experts = {}
        self.expert_workload = defaultdict(int)

        # 知识库
        self.domain_knowledge = {}
        self.case_library = {}
        self.expert_rules = {}

    async def analyze(self, scenario_data: Dict[str, Any],
                     strategic_framework: Dict[str, Any]) -> Dict[str, Any]:
        """执行专业分析"""
        start_time = time.time()

        try:
            # 步骤1: 识别需要的专业领域
            required_domains = await self._identify_required_domains(
                scenario_data, strategic_framework
            )

            # 步骤2: 选择合适的专家
            selected_experts = await self.expert_manager.select_experts(
                required_domains, scenario_data
            )

            # 步骤3: 并行执行专家分析
            analysis_results = await self.analysis_orchestrator.parallel_analysis(
                selected_experts, scenario_data, strategic_framework
            )

            # 步骤4: 构建专家共识
            consensus = await self.consensus_builder.build_consensus(
                analysis_results, selected_experts
            )

            # 步骤5: 生成综合专家报告
            expert_report = await self._generate_expert_report(
                analysis_results, consensus, scenario_data
            )

            result = {
                'scenario_analysis': expert_report,
                'individual_analyses': analysis_results,
                'expert_consensus': consensus,
                'participating_experts': selected_experts,
                'analysis_time': time.time() - start_time,
                'confidence_score': self._calculate_overall_confidence(analysis_results),
                'quality_metrics': self._assess_analysis_quality(analysis_results)
            }

            return result

        except Exception as e:
            logger.error(f"F-Agent analysis failed: {e}")
            raise

    async def communicate(self, message: AgentMessage) -> Optional[AgentMessage]:
        """通信方法"""
        try:
            if message.message_type == "EXPERT_ANALYSIS_REQUEST":
                return await self._handle_analysis_request(message)
            elif message.message_type == "KNOWLEDGE_UPDATE":
                return await self._handle_knowledge_update(message)
            elif message.message_type == "EXPERT_CONSENSUS_REQUEST":
                return await self._handle_consensus_request(message)
            elif message.message_type == "DOMAIN_QUERY":
                return await self._handle_domain_query(message)
            else:
                return None
        except Exception as e:
            logger.error(f"F-Agent communication failed: {e}")
            return None

    async def update_state(self, new_state: AgentState) -> bool:
        """状态更新方法"""
        return await super().update_state(new_state)

    async def _identify_required_domains(self, scenario_data: Dict[str, Any],
                                        strategic_framework: Dict[str, Any]) -> Set[ExpertiseDomain]:
        """识别所需的专业领域"""
        domains = set()

        try:
            # 基于事件类型识别领域
            event_type = scenario_data.get('event_type', '').lower()

            domain_mapping = {
                'earthquake': {ExpertiseDomain.GEOLOGICAL, ExpertiseDomain.INFRASTRUCTURE},
                'flood': {ExpertiseDomain.METEOROLOGICAL, ExpertiseDomain.INFRASTRUCTURE},
                'fire': {ExpertiseDomain.INFRASTRUCTURE, ExpertiseDomain.PUBLIC_HEALTH},
                'epidemic': {ExpertiseDomain.PUBLIC_HEALTH, ExpertiseDomain.LOGISTICS},
                'landslide': {ExpertiseDomain.GEOLOGICAL, ExpertiseDomain.ENVIRONMENTAL},
                'storm': {ExpertiseDomain.METEOROLOGICAL, ExpertiseDomain.INFRASTRUCTURE},
                'chemical': {ExpertiseDomain.ENVIRONMENTAL, ExpertiseDomain.PUBLIC_HEALTH}
            }

            domains.update(domain_mapping.get(event_type, {ExpertiseDomain.SECURITY}))

            # 基于战略框架补充领域
            if 'strategic_goals' in strategic_framework:
                for goal in strategic_framework['strategic_goals']:
                    if 'infrastructure' in str(goal).lower():
                        domains.add(ExpertiseDomain.INFRASTRUCTURE)
                    if 'health' in str(goal).lower():
                        domains.add(ExpertiseDomain.PUBLIC_HEALTH)
                    if 'environment' in str(goal).lower():
                        domains.add(ExpertiseDomain.ENVIRONMENTAL)

            # 基于环境因素补充领域
            environment_data = scenario_data.get('environment_data', {})
            if 'weather' in environment_data:
                domains.add(ExpertiseDomain.METEOROLOGICAL)
            if 'terrain' in environment_data:
                domains.add(ExpertiseDomain.GEOLOGICAL)

            return domains

        except Exception as e:
            logger.error(f"Failed to identify required domains: {e}")
            return {ExpertiseDomain.SECURITY}  # 默认领域

    async def _generate_expert_report(self, analysis_results: List[ExpertAnalysis],
                                    consensus: ExpertConsensus,
                                    scenario_data: Dict[str, Any]) -> Dict[str, Any]:
        """生成综合专家报告"""
        try:
            report = {
                'report_id': f"expert_report_{int(time.time())}",
                'scenario_id': scenario_data.get('scenario_id'),
                'generation_timestamp': datetime.now().isoformat(),
                'executive_summary': await self._generate_executive_summary(analysis_results, consensus),
                'technical_findings': await self._compile_technical_findings(analysis_results),
                'feasibility_assessment': await self._assess_overall_feasibility(analysis_results),
                'risk_analysis': await self._compile_risk_analysis(analysis_results),
                'expert_recommendations': await self._compile_recommendations(analysis_results, consensus),
                'consensus_summary': {
                    'consensus_level': consensus.consensus_level,
                    'agreed_points': consensus.agreed_points,
                    'disagreed_points': consensus.disagreed_points
                },
                'confidence_analysis': await self._analyze_confidence_distribution(analysis_results),
                'quality_assessment': await self._assess_report_quality(analysis_results, consensus),
                'limitations_and_caveats': await self._identify_limitations(analysis_results),
                'next_steps': await self._recommend_next_steps(consensus)
            }

            return report

        except Exception as e:
            logger.error(f"Failed to generate expert report: {e}")
            raise

    def _calculate_overall_confidence(self, analysis_results: List[ExpertAnalysis]) -> float:
        """计算总体置信度"""
        if not analysis_results:
            return 0.0

        try:
            # 加权平均置信度
            total_weight = 0
            weighted_confidence = 0

            for analysis in analysis_results:
                weight = self._get_expert_weight(analysis.expert_id)
                confidence_value = analysis.confidence_level.value / 5.0  # 标准化到0-1

                weighted_confidence += confidence_value * weight
                total_weight += weight

            if total_weight > 0:
                return weighted_confidence / total_weight
            else:
                return sum(a.confidence_level.value for a in analysis_results) / (len(analysis_results) * 5.0)

        except Exception as e:
            logger.error(f"Failed to calculate overall confidence: {e}")
            return 0.5  # 默认中等置信度

    def _get_expert_weight(self, expert_id: str) -> float:
        """获取专家权重"""
        # 基于专家历史表现、领域权威性等计算权重
        # 这里简化处理，实际应该基于历史数据
        return 1.0

    async def _assess_analysis_quality(self, analysis_results: List[ExpertAnalysis]) -> Dict[str, Any]:
        """评估分析质量"""
        try:
            quality_metrics = {
                'completeness_score': 0.0,
                'consistency_score': 0.0,
                'depth_score': 0.0,
                'evidence_support_score': 0.0,
                'overall_quality_score': 0.0
            }

            if not analysis_results:
                return quality_metrics

            # 完整性评分
            completeness_scores = []
            for analysis in analysis_results:
                completeness = self._assess_analysis_completeness(analysis)
                completeness_scores.append(completeness)
            quality_metrics['completeness_score'] = sum(completeness_scores) / len(completeness_scores)

            # 一致性评分
            consistency_score = self._assess_analysis_consistency(analysis_results)
            quality_metrics['consistency_score'] = consistency_score

            # 深度评分
            depth_scores = []
            for analysis in analysis_results:
                depth = self._assess_analysis_depth(analysis)
                depth_scores.append(depth)
            quality_metrics['depth_score'] = sum(depth_scores) / len(depth_scores)

            # 证据支持评分
            evidence_scores = []
            for analysis in analysis_results:
                evidence = self._assess_evidence_support(analysis)
                evidence_scores.append(evidence)
            quality_metrics['evidence_support_score'] = sum(evidence_scores) / len(evidence_scores)

            # 总体质量评分
            quality_metrics['overall_quality_score'] = (
                quality_metrics['completeness_score'] * 0.3 +
                quality_metrics['consistency_score'] * 0.25 +
                quality_metrics['depth_score'] * 0.25 +
                quality_metrics['evidence_support_score'] * 0.2
            )

            return quality_metrics

        except Exception as e:
            logger.error(f"Failed to assess analysis quality: {e}")
            return {'overall_quality_score': 0.5}

class ExpertManager:
    """专家管理器"""

    def __init__(self):
        self.expert_registry = {}
        self.domain_experts = defaultdict(list)
        self.expert_performance = defaultdict(dict)

    async def select_experts(self, required_domains: Set[ExpertiseDomain],
                           scenario_data: Dict[str, Any]) -> List[str]:
        """选择合适的专家"""
        selected_experts = []

        try:
            for domain in required_domains:
                domain_experts = self.domain_experts.get(domain, [])

                # 基于场景特征和专家历史表现选择专家
                suitable_experts = await self._filter_suitable_experts(
                    domain_experts, scenario_data
                )

                # 选择最适合的专家（每个领域最多3个）
                top_experts = sorted(
                    suitable_experts,
                    key=lambda x: self._calculate_expert_suitability(x, scenario_data),
                    reverse=True
                )[:3]

                selected_experts.extend(top_experts)

            return list(set(selected_experts))  # 去重

        except Exception as e:
            logger.error(f"Failed to select experts: {e}")
            return []

class KnowledgeBase:
    """知识库"""

    def __init__(self):
        self.knowledge_graph = nx.DiGraph()
        self.vector_index = None  # 可以集成向量数据库
        self.rule_engine = None

    async def query_knowledge(self, domain: ExpertiseDomain,
                            query: str, context: Dict[str, Any]) -> List[ExpertKnowledge]:
        """查询相关知识"""
        try:
            # 基于领域和查询内容检索知识
            relevant_knowledge = []

            # 图谱查询
            graph_results = self._query_knowledge_graph(domain, query)
            relevant_knowledge.extend(graph_results)

            # 向量相似度查询
            if self.vector_index:
                vector_results = await self._query_vector_index(query, context)
                relevant_knowledge.extend(vector_results)

            # 规则匹配
            rule_results = self._match_expert_rules(domain, query)
            relevant_knowledge.extend(rule_results)

            # 去重和排序
            unique_knowledge = self._deduplicate_knowledge(relevant_knowledge)
            sorted_knowledge = sorted(
                unique_knowledge,
                key=lambda x: x.confidence.value,
                reverse=True
            )

            return sorted_knowledge[:10]  # 返回最相关的10条知识

        except Exception as e:
            logger.error(f"Failed to query knowledge: {e}")
            return []

class ConsensusBuilder:
    """共识构建器"""

    def __init__(self):
        self.consensus_algorithms = {
            'voting': self._voting_consensus,
            'weighted': self._weighted_consensus,
            'delphi': self._delphi_consensus,
            'analytic_hierarchy': self._analytic_hierarchy_consensus
        }

    async def build_consensus(self, analysis_results: List[ExpertAnalysis],
                            participating_experts: List[str]) -> ExpertConsensus:
        """构建专家共识"""
        try:
            # 选择共识算法
            algorithm = self._select_consensus_algorithm(analysis_results)

            # 执行共识计算
            consensus_result = await self.consensus_algorithms[algorithm](analysis_results)

            # 创建共识对象
            consensus = ExpertConsensus(
                consensus_id=f"consensus_{int(time.time())}",
                scenario_id=analysis_results[0].scenario_id if analysis_results else "",
                participating_experts=participating_experts,
                consensus_timestamp=datetime.now(),
                consensus_level=consensus_result['consensus_level'],
                agreed_points=consensus_result['agreed_points'],
                disagreed_points=consensus_result['disagreed_points'],
                consensus_recommendations=consensus_result['recommendations'],
                confidence_distribution=consensus_result['confidence_distribution'],
                consensus_quality_score=consensus_result['quality_score']
            )

            return consensus

        except Exception as e:
            logger.error(f"Failed to build consensus: {e}")
            raise
```

### 开发工作流程
1. 接收S-Agent的战略框架和场景数据
2. 识别所需的专业领域和专家
3. 从知识库检索相关专业知识
4. 并行执行多个专家分析
5. 构建专家共识和解决冲突
6. 生成结构化的专家分析报告
7. 提供技术可行性评估和建议

### 依赖关系说明
- 依赖Story 2.1完成的Agent基础框架
- 接收Story 2.2 S-Agent的战略框架输入
- 为Story 2.5 E-Agent提供技术指导
- 为整个Epic提供专业分析支持

### 重要注意事项
- F-Agent需要维护高质量的专家知识库
- 专家选择需要基于领域匹配度和历史表现
- 共识构建需要处理专家间的分歧
- 分析结果需要提供可操作的技术建议
- 知识库需要定期更新和维护

### 测试策略
- 单元测试: 测试专家管理、知识查询、推理引擎
- 集成测试: 测试完整的专家分析流程
- 专家评估测试: 邀请领域专家评估分析质量
- 共识算法测试: 验证不同共识算法的效果

### Testing

#### 测试标准
- 测试文件位置: tests/f_agent/目录
- 专家选择测试: 验证专家选择算法的正确性
- 知识查询测试: 验证知识检索的准确性和完整性
- 分析质量测试: 验证专家分析的专业性和深度
- 共识构建测试: 验证共识算法的有效性

#### 测试框架和模式
- 单元测试: pytest + pytest-asyncio
- 模拟测试: pytest + unittest.mock
- 集成测试: pytest + 测试数据集
- 专家评估测试: 专家评审 + 问卷调查

#### 特定测试要求
- 多领域专家协作的测试
- 知识库查询性能和准确性测试
- 专家共识算法的有效性验证
- 冲突解决机制的健壮性测试
- 分析报告的专业性和可读性测试

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-20 | 1.0 | 初始故事创建 | John (PM) |

## Dev Agent Record

### Agent Model Used
(待开发时填写)

### Debug Log References
(待开发时填写)

### Completion Notes List
(待开发时填写)

### File List
(待开发时填写)

## QA Results
(待QA测试时填写)