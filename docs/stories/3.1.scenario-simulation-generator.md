# Story 3.1: 应急场景模拟数据生成器

## Status
Draft

## Story

**As a** 系统开发者和测试人员,
**I want** 一个高质量的应急场景模拟数据生成器,
**so that** 为S-A-F-E四个Agent提供逼真的测试数据，验证其协作分析能力。

## Acceptance Criteria

1. 生成器能够创建多种类型的应急场景数据
2. 支持动态数据演化，模拟真实灾害发展过程
3. 提供多源数据模拟，包括传感器、GIS、报告等数据源
4. 数据质量符合真实灾害统计特征
5. 支持场景参数化配置和复杂度调整

## Tasks / Subtasks

- [ ] 实现场景配置系统 (AC: #1)
  - [ ] 设计场景数据结构
    - [ ] EmergencyScenario基类设计
    - [ ] 场景参数配置Schema
    - [ ] 地理环境参数模型
    - [ ] 灾害参数模型
  - [ ] 实现场景类型定义
    - [ ] 洞庭湖决口场景类
    - [ ] 地震灾害场景类
    - [ ] 危化品泄漏场景类
    - [ ] 复合灾害场景类
  - [ ] 创建场景配置管理器
    - [ ] 配置文件加载器
    - [ ] 参数验证器
    - [ ] 场景模板管理器
    - [ ] 配置版本控制器
  - [ ] 实现场景复杂度控制
    - [ ] 复杂度评估算法
    - [ ] 参数调整策略
    - [ ] 场景难度分级
    - [ ] 动态复杂度调整
  - [ ] 设计场景元数据管理
    - [ ] 场景描述信息
    - [ ] 创建和修改历史
    - [ ] 标签和分类系统
    - [ ] 场景关联关系

- [ ] 实现动态数据生成引擎 (AC: #2)
  - [ ] 设计时间演化模型
    - [ ] 时间步进控制器
    - [ ] 状态转换逻辑
    - [ ] 演化参数计算器
    - [ ] 随机性控制机制
  - [ ] 实现水文数据生成器
    - [ ] 水位变化模拟
    - [ ] 流量计算模型
    - [ ] 决口扩展算法
    - [ ] 影响范围计算
  - [ ] 创建环境数据生成器
    - [ ] 天气数据模拟
    - [ ] 地形影响模型
    - [ ] 环境参数变化
    - [ ] 次生灾害模拟
  - [ ] 实现社会数据生成器
    - [ ] 人口状态更新
    - [ ] 基础设施状态
    - [ ] 救援资源状态
    - [ ] 社会秩序指标
  - [ ] 设计数据质量控制
    - [ ] 数据一致性检查
    - [ ] 合理性验证
    - [ ] 异常值检测
    - [ ] 数据修正机制

- [ ] 实现多源数据模拟 (AC: #3)
  - [ ] 设计GIS数据模拟器
    - [ ] 地理坐标系统
    - [ ] 空间数据生成
    - [ ] 地图数据模拟
    - [ ] 空间关系计算
  - [ ] 实现传感器数据模拟
    - [ ] 传感器设备模型
    - [ ] 数据采样特性
    - [ ] 设备故障模拟
    - [ ] 数据噪声添加
  - [ ] 创建报告数据模拟器
    - [ ] 人工报告生成
    - [ ] 通信延迟模拟
    - [ ] 信息不完整性
    - [ ] 主观偏差模拟
  - [ ] 实现仿真数据模拟
    - [ ] 灾害演化模型
    - [ ] 影响预测算法
    - [ ] 不确定性分析
    - [ ] 概率分布模拟
  - [ ] 设计数据同步机制
    - [ ] 时间戳同步
    - [ ] 数据关联关系
    - [ ] 一致性保证
    - [ ] 冲突检测解决

- [ ] 实现数据质量保证 (AC: #4)
  - [ ] 设计真实性评估模型
    - [ ] 统计特征对比
    - [ ] 历史数据验证
    - [ ] 专家知识验证
    - [ ] 真实性评分系统
  - [ ] 实现数据质量监控
    - [ ] 质量指标计算
    - [ ] 实时质量监控
    - [ ] 质量趋势分析
    - [ ] 质量预警机制
  - [ ] 创建数据校验系统
    - [ ] 格式校验器
    - [ ] 范围校验器
    - [ ] 逻辑校验器
    - [ ] 关系校验器
  - [ ] 实现数据修正功能
    - [ ] 自动修正算法
    - [ ] 人工修正接口
    - [ ] 修正历史记录
    - [ ] 修正效果评估
  - [ ] 设计质量报告生成
    - [ ] 质量统计报告
    - [ ] 问题分析报告
    - [ ] 改进建议报告
    - [ ] 趋势分析报告

- [ ] 实现场景管理接口 (AC: #5)
  - [ ] 设计场景管理API
    - [ ] 场景创建接口
    - [ ] 场景查询接口
    - [ ] 场景更新接口
    - [ ] 场景删除接口
  - [ ] 实现数据流控制
    - [ ] 数据流启动/停止
    - [ ] 流速控制
    - [ ] 数据过滤
    - [ ] 流状态监控
  - [ ] 创建场景模板系统
    - [ ] 模板定义格式
    - [ ] 模板继承机制
    - [ ] 模板参数化
    - [ ] 模板库管理
  - [ ] 实现批量操作支持
    - [ ] 批量场景创建
    - [ ] 批量数据生成
    - [ ] 批量质量检查
    - [ ] 批量导出功能
  - [ ] 设计监控和日志系统
    - [ ] 运行状态监控
    - [ ] 性能指标收集
    - [ ] 操作日志记录
    - [ ] 异常日志管理

## Dev Notes

### 技术架构信息
场景模拟数据生成器采用以下技术栈：
- 核心框架: Python + NumPy + SciPy
- 数据处理: Pandas + Dask (大数据处理)
- 地理信息: GeoPandas + Shapely
- 时间序列: Pandas + Prophet (时间预测)
- 随机模拟: NumPy Random + SciPy Stats
- 配置管理: Pydantic + YAML
- 数据存储: HDF5 + Parquet + SQLite

### 核心设计架构
```python
from typing import Dict, List, Any, Optional, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import json
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from abc import ABC, abstractmethod
import logging
from pathlib import Path
import yaml
from pydantic import BaseModel, validator

class ScenarioType(Enum):
    """场景类型枚举"""
    FLOOD_BREACH = "flood_breach"         # 决堤洪水
    EARTHQUAKE = "earthquake"             # 地震灾害
    CHEMICAL_LEAK = "chemical_leak"       # 化学品泄漏
    COMPOUND_DISASTER = "compound_disaster" # 复合灾害

class DataStreamType(Enum):
    """数据流类型枚举"""
    SENSOR_DATA = "sensor_data"           # 传感器数据
    GIS_DATA = "gis_data"                # 地理信息数据
    REPORT_DATA = "report_data"           # 报告数据
    SIMULATION_DATA = "simulation_data"   # 仿真数据
    WEATHER_DATA = "weather_data"         # 天气数据

@dataclass
class GeoLocation:
    """地理位置数据模型"""
    latitude: float
    longitude: float
    altitude: Optional[float] = None
    coordinate_system: str = "WGS84"
    description: Optional[str] = None

@dataclass
class GeographyData:
    """地理环境数据模型"""
    center_location: GeoLocation
    area_size: float  # 平方公里
    terrain_type: str  # 平原、山地、丘陵等
    elevation_range: Tuple[float, float]  # 海拔范围
    water_bodies: List[Dict[str, Any]]  # 水体信息
    transportation: List[Dict[str, Any]]  # 交通网络
    buildings: List[Dict[str, Any]]  # 建筑物分布
    population_density: float  # 人口密度

@dataclass
class DisasterParameters:
    """灾害参数数据模型"""
    disaster_type: ScenarioType
    magnitude: float  # 灾害强度
    affected_area: float  # 影响面积
    duration: int  # 持续时间(小时)
    evolution_speed: float  # 演化速度
    specific_params: Dict[str, Any] = field(default_factory=dict)

class ScenarioConfig(BaseModel):
    """场景配置数据模型"""
    scenario_id: str
    scenario_name: str
    scenario_type: ScenarioType
    description: str

    # 地理环境配置
    geography: GeographyData

    # 灾害参数配置
    disaster: DisasterParameters

    # 社会参数配置
    social_params: Dict[str, Any]

    # 救援资源配置
    rescue_resources: Dict[str, Any]

    # 数据生成配置
    data_config: Dict[str, Any]

    # 时间配置
    start_time: datetime
    time_step: int  # 时间步长(秒)
    total_duration: int  # 总持续时间(秒)

    # 质量控制配置
    quality_config: Dict[str, Any] = field(default_factory=dict)

    class Config:
        arbitrary_types_allowed = True

class DataStream(ABC):
    """数据流抽象基类"""

    def __init__(self, stream_id: str, config: Dict[str, Any]):
        self.stream_id = stream_id
        self.config = config
        self.current_time = None
        self.is_active = False

    @abstractmethod
    async def initialize(self, scenario_config: ScenarioConfig) -> bool:
        """初始化数据流"""
        pass

    @abstractmethod
    async def generate_data_point(self, current_time: datetime) -> Dict[str, Any]:
        """生成单个数据点"""
        pass

    @abstractmethod
    async def cleanup(self) -> bool:
        """清理资源"""
        pass

class ScenarioSimulator:
    """场景模拟器主类"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.scenario_config = None
        self.data_streams = {}
        self.is_running = False
        self.simulation_handle = None

        # 组件初始化
        self.quality_controller = QualityController()
        self.state_manager = StateManager()
        self.event_generator = EventGenerator()

    async def initialize_scenario(self, scenario_config: ScenarioConfig) -> str:
        """初始化场景模拟"""
        try:
            self.scenario_config = scenario_config

            # 验证配置
            await self._validate_scenario_config(scenario_config)

            # 初始化数据流
            await self._initialize_data_streams(scenario_config)

            # 初始化状态管理器
            await self.state_manager.initialize(scenario_config)

            # 创建模拟句柄
            simulation_handle = str(uuid.uuid4())
            self.simulation_handle = simulation_handle

            logger.info(f"Scenario {scenario_config.scenario_id} initialized successfully")
            return simulation_handle

        except Exception as e:
            logger.error(f"Failed to initialize scenario: {e}")
            raise

    async def start_simulation(self, simulation_handle: str) -> bool:
        """启动场景模拟"""
        try:
            if simulation_handle != self.simulation_handle:
                raise ValueError("Invalid simulation handle")

            if self.is_running:
                logger.warning("Simulation is already running")
                return False

            # 启动数据流
            for stream_id, stream in self.data_streams.items():
                stream.is_active = True

            self.is_running = True

            # 启动模拟循环
            asyncio.create_task(self._simulation_loop())

            logger.info("Simulation started successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to start simulation: {e}")
            return False

    async def get_data_stream(self, stream_type: DataStreamType) -> AsyncIterator[Dict[str, Any]]:
        """获取数据流"""
        try:
            while self.is_running:
                current_time = self.state_manager.get_current_time()

                # 生成各类型数据
                for stream_id, stream in self.data_streams.items():
                    if stream.stream_type == stream_type and stream.is_active:
                        data_point = await stream.generate_data_point(current_time)

                        # 质量控制
                        if await self.quality_controller.validate_data_point(data_point):
                            yield data_point

                # 推进时间
                await self.state_manager.advance_time()
                await asyncio.sleep(self.scenario_config.time_step)

        except Exception as e:
            logger.error(f"Error in data stream: {e}")
            raise

    async def _simulation_loop(self):
        """模拟主循环"""
        try:
            while self.is_running:
                current_time = self.state_manager.get_current_time()

                # 检查是否达到结束时间
                if current_time >= self.scenario_config.start_time + timedelta(seconds=self.scenario_config.total_duration):
                    await self.stop_simulation()
                    break

                # 生成事件
                events = await self.event_generator.generate_events(current_time)

                # 处理事件
                for event in events:
                    await self._handle_simulation_event(event)

                # 推进时间
                await self.state_manager.advance_time()
                await asyncio.sleep(1)  # 控制模拟速度

        except Exception as e:
            logger.error(f"Error in simulation loop: {e}")
            await self.stop_simulation()

    async def _initialize_data_streams(self, scenario_config: ScenarioConfig):
        """初始化数据流"""
        try:
            # 根据场景类型创建相应的数据流
            data_stream_configs = scenario_config.data_config.get('streams', {})

            for stream_config in data_stream_configs:
                stream_type = DataStreamType(stream_config['type'])
                stream_class = self._get_stream_class(stream_type)

                stream = stream_class(stream_config['id'], stream_config)

                # 初始化数据流
                if await stream.initialize(scenario_config):
                    self.data_streams[stream.stream_id] = stream
                    logger.info(f"Data stream {stream.stream_id} initialized")
                else:
                    logger.error(f"Failed to initialize data stream {stream.stream_id}")

        except Exception as e:
            logger.error(f"Failed to initialize data streams: {e}")
            raise

class FloodBreachSimulator(ScenarioSimulator):
    """决堤洪水场景模拟器"""

    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.breach_model = BreachEvolutionModel()
        self.hydro_model = HydrologyModel()
        self.impact_model = ImpactAssessmentModel()

    async def initialize_scenario(self, scenario_config: ScenarioConfig) -> str:
        """初始化决堤场景"""
        try:
            # 调用父类初始化
            simulation_handle = await super().initialize_scenario(scenario_config)

            # 初始化决堤模型
            await self.breach_model.initialize(
                scenario_config.disaster.specific_params
            )

            # 初始化水文模型
            await self.hydro_model.initialize(
                scenario_config.geography,
                scenario_config.disaster
            )

            # 初始化影响评估模型
            await self.impact_model.initialize(scenario_config)

            return simulation_handle

        except Exception as e:
            logger.error(f"Failed to initialize flood breach scenario: {e}")
            raise

    async def _calculate_breach_evolution(self, current_time: datetime) -> Dict[str, Any]:
        """计算决口演化"""
        try:
            # 计算当前决口尺寸
            breach_dimensions = await self.breach_model.calculate_breach_size(
                current_time, self.scenario_config.start_time
            )

            # 计算流量
            flow_rate = await self.hydro_model.calculate_flow_rate(
                breach_dimensions, current_time
            )

            # 计算淹没范围
            affected_area = await self.impact_model.calculate_flood_area(
                flow_rate, current_time
            )

            return {
                'timestamp': current_time,
                'breach_dimensions': breach_dimensions,
                'flow_rate': flow_rate,
                'affected_area': affected_area,
                'water_level': await self.hydro_model.get_water_level(current_time)
            }

        except Exception as e:
            logger.error(f"Failed to calculate breach evolution: {e}")
            return {}

class SensorDataStream(DataStream):
    """传感器数据流"""

    def __init__(self, stream_id: str, config: Dict[str, Any]):
        super().__init__(stream_id, config)
        self.sensor_type = config['sensor_type']
        self.location = GeoLocation(**config['location'])
        self.sampling_rate = config.get('sampling_rate', 60)  # 秒
        self.accuracy = config.get('accuracy', 0.95)
        self.noise_level = config.get('noise_level', 0.02)
        self.last_sample_time = None

    async def initialize(self, scenario_config: ScenarioConfig) -> bool:
        """初始化传感器数据流"""
        try:
            self.current_time = scenario_config.start_time
            self.last_sample_time = self.current_time

            # 根据传感器类型初始化特定参数
            await self._initialize_sensor_parameters()

            logger.info(f"Sensor data stream {self.stream_id} initialized")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize sensor data stream: {e}")
            return False

    async def generate_data_point(self, current_time: datetime) -> Dict[str, Any]:
        """生成传感器数据点"""
        try:
            # 检查采样时间
            if (current_time - self.last_sample_time).total_seconds() < self.sampling_rate:
                return None

            # 生成基础测量值
            base_value = await self._generate_base_measurement(current_time)

            # 添加噪声
            noisy_value = self._add_measurement_noise(base_value)

            # 模拟设备故障
            if np.random.random() < 0.001:  # 0.1% 故障率
                return await self._generate_faulty_data()

            data_point = {
                'stream_id': self.stream_id,
                'sensor_type': self.sensor_type,
                'location': self.location,
                'timestamp': current_time.isoformat(),
                'value': noisy_value,
                'quality': self._calculate_data_quality(),
                'metadata': {
                    'sampling_rate': self.sampling_rate,
                    'accuracy': self.accuracy,
                    'sensor_id': self.stream_id
                }
            }

            self.last_sample_time = current_time
            return data_point

        except Exception as e:
            logger.error(f"Failed to generate sensor data point: {e}")
            return None

    async def _generate_base_measurement(self, current_time: datetime) -> float:
        """生成基础测量值"""
        # 根据传感器类型和时间生成相应的测量值
        if self.sensor_type == 'water_level':
            # 水位传感器：模拟水位变化
            time_factor = (current_time - self.current_time).total_seconds() / 3600
            base_value = 10.0 + 5.0 * np.sin(time_factor * 0.1) + np.random.normal(0, 0.5)
        elif self.sensor_type == 'flow_rate':
            # 流量传感器：模拟流量变化
            time_factor = (current_time - self.current_time).total_seconds() / 3600
            base_value = 100.0 + 50.0 * np.cos(time_factor * 0.15) + np.random.normal(0, 2.0)
        else:
            # 默认传感器
            base_value = np.random.normal(50, 10)

        return base_value

class QualityController:
    """数据质量控制器"""

    def __init__(self):
        self.quality_rules = {}
        self.quality_metrics = defaultdict(list)
        self.quality_thresholds = {}

    async def validate_data_point(self, data_point: Dict[str, Any]) -> bool:
        """验证数据点质量"""
        try:
            # 应用质量规则
            for rule_name, rule_func in self.quality_rules.items():
                if not await rule_func(data_point):
                    logger.warning(f"Data point failed quality rule {rule_name}")
                    return False

            # 检查质量阈值
            quality_score = await self._calculate_quality_score(data_point)
            if quality_score < self.quality_thresholds.get('minimum', 0.8):
                logger.warning(f"Data point quality score {quality_score} below threshold")
                return False

            return True

        except Exception as e:
            logger.error(f"Error validating data point: {e}")
            return False
```

### 开发工作流程
1. 设计场景配置数据结构和Schema定义
2. 实现各种应急场景的参数化模型
3. 开发动态数据生成引擎和时间演化算法
4. 构建多源数据模拟器（传感器、GIS、报告、仿真）
5. 实现数据质量控制和验证机制
6. 创建场景管理和数据流控制接口
7. 建立监控、日志和性能优化机制

### 依赖关系说明
- 依赖Story 2.1-2.7完成的Agent框架和协作机制
- 为Story 3.2-3.7的Agent能力测试提供数据基础
- 需要与后续用户界面开发保持数据格式兼容

### 重要注意事项
- 模拟数据必须符合真实灾害的统计特征
- 需要支持多种数据源的时间同步
- 数据质量保证是系统的关键要素
- 性能优化需要支持大规模并发场景
- 需要建立完善的数据验证和监控机制

### 测试策略
- 单元测试: 测试各种数据生成算法的准确性
- 集成测试: 测试多源数据的同步和一致性
- 性能测试: 测试大规模数据生成的性能
- 真实性测试: 对比模拟数据与真实统计数据

### Testing

#### 测试标准
- 测试文件位置: tests/simulation/目录
- 场景生成测试: 验证各种场景类型的生成正确性
- 数据质量测试: 验证生成数据的质量指标
- 性能测试: 验证大规模数据生成的性能指标
- 一致性测试: 验证多源数据的一致性和同步性

#### 测试框架和模式
- 单元测试: pytest + numpy.testing
- 数据质量测试: 自定义质量验证框架
- 性能测试: pytest + pytest-benchmark
- 统计验证: scipy.stats + 真实数据对比

#### 特定测试要求
- 洞庭湖决口场景的真实性验证
- 地震灾害场景的统计特征符合度测试
- 时间序列数据的连续性和合理性测试
- 多源数据同步的准确性测试
- 异常情况和故障的模拟测试

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-20 | 1.0 | 初始故事创建 | John (PM) |

## Dev Agent Record

### Agent Model Used
(待开发时填写)

### Debug Log References
(待开发时填写)

### Completion Notes List
(待开发时填写)

### File List
(待开发时填写)

## QA Results
(待QA测试时填写)